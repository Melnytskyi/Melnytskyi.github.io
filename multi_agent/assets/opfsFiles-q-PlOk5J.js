(function(){"use strict";var L={exports:{}},B;function W(){return B||(B=1,(function(M){var r=function(){this.Diff_Timeout=1,this.Diff_EditCost=4,this.Match_Threshold=.5,this.Match_Distance=1e3,this.Patch_DeleteThreshold=.5,this.Patch_Margin=4,this.Match_MaxBits=32},l=-1,i=1,h=0;r.Diff=function(e,t){return[e,t]},r.prototype.diff_main=function(e,t,a,s){typeof s>"u"&&(this.Diff_Timeout<=0?s=Number.MAX_VALUE:s=new Date().getTime()+this.Diff_Timeout*1e3);var o=s;if(e==null||t==null)throw new Error("Null input. (diff_main)");if(e==t)return e?[new r.Diff(h,e)]:[];typeof a>"u"&&(a=!0);var n=a,c=this.diff_commonPrefix(e,t),f=e.substring(0,c);e=e.substring(c),t=t.substring(c),c=this.diff_commonSuffix(e,t);var u=e.substring(e.length-c);e=e.substring(0,e.length-c),t=t.substring(0,t.length-c);var g=this.diff_compute_(e,t,n,o);return f&&g.unshift(new r.Diff(h,f)),u&&g.push(new r.Diff(h,u)),this.diff_cleanupMerge(g),g},r.prototype.diff_compute_=function(e,t,a,s){var o;if(!e)return[new r.Diff(i,t)];if(!t)return[new r.Diff(l,e)];var n=e.length>t.length?e:t,c=e.length>t.length?t:e,f=n.indexOf(c);if(f!=-1)return o=[new r.Diff(i,n.substring(0,f)),new r.Diff(h,c),new r.Diff(i,n.substring(f+c.length))],e.length>t.length&&(o[0][0]=o[2][0]=l),o;if(c.length==1)return[new r.Diff(l,e),new r.Diff(i,t)];var u=this.diff_halfMatch_(e,t);if(u){var g=u[0],w=u[1],d=u[2],y=u[3],v=u[4],m=this.diff_main(g,d,a,s),_=this.diff_main(w,y,a,s);return m.concat([new r.Diff(h,v)],_)}return a&&e.length>100&&t.length>100?this.diff_lineMode_(e,t,s):this.diff_bisect_(e,t,s)},r.prototype.diff_lineMode_=function(e,t,a){var s=this.diff_linesToChars_(e,t);e=s.chars1,t=s.chars2;var o=s.lineArray,n=this.diff_main(e,t,!1,a);this.diff_charsToLines_(n,o),this.diff_cleanupSemantic(n),n.push(new r.Diff(h,""));for(var c=0,f=0,u=0,g="",w="";c<n.length;){switch(n[c][0]){case i:u++,w+=n[c][1];break;case l:f++,g+=n[c][1];break;case h:if(f>=1&&u>=1){n.splice(c-f-u,f+u),c=c-f-u;for(var d=this.diff_main(g,w,!1,a),y=d.length-1;y>=0;y--)n.splice(c,0,d[y]);c=c+d.length}u=0,f=0,g="",w="";break}c++}return n.pop(),n},r.prototype.diff_bisect_=function(e,t,a){for(var s=e.length,o=t.length,n=Math.ceil((s+o)/2),c=n,f=2*n,u=new Array(f),g=new Array(f),w=0;w<f;w++)u[w]=-1,g[w]=-1;u[c+1]=0,g[c+1]=0;for(var d=s-o,y=d%2!=0,v=0,m=0,_=0,D=0,p=0;p<n&&!(new Date().getTime()>a);p++){for(var F=-p+v;F<=p-m;F+=2){var H=c+F,A;F==-p||F!=p&&u[H-1]<u[H+1]?A=u[H+1]:A=u[H-1]+1;for(var P=A-F;A<s&&P<o&&e.charAt(A)==t.charAt(P);)A++,P++;if(u[H]=A,A>s)m+=2;else if(P>o)v+=2;else if(y){var S=c+d-F;if(S>=0&&S<f&&g[S]!=-1){var E=s-g[S];if(A>=E)return this.diff_bisectSplit_(e,t,A,P,a)}}}for(var $=-p+_;$<=p-D;$+=2){var S=c+$,E;$==-p||$!=p&&g[S-1]<g[S+1]?E=g[S+1]:E=g[S-1]+1;for(var R=E-$;E<s&&R<o&&e.charAt(s-E-1)==t.charAt(o-R-1);)E++,R++;if(g[S]=E,E>s)D+=2;else if(R>o)_+=2;else if(!y){var H=c+d-$;if(H>=0&&H<f&&u[H]!=-1){var A=u[H],P=c+A-H;if(E=s-E,A>=E)return this.diff_bisectSplit_(e,t,A,P,a)}}}}return[new r.Diff(l,e),new r.Diff(i,t)]},r.prototype.diff_bisectSplit_=function(e,t,a,s,o){var n=e.substring(0,a),c=t.substring(0,s),f=e.substring(a),u=t.substring(s),g=this.diff_main(n,c,!1,o),w=this.diff_main(f,u,!1,o);return g.concat(w)},r.prototype.diff_linesToChars_=function(e,t){var a=[],s={};a[0]="";function o(u){for(var g="",w=0,d=-1,y=a.length;d<u.length-1;){d=u.indexOf(`
`,w),d==-1&&(d=u.length-1);var v=u.substring(w,d+1);(s.hasOwnProperty?s.hasOwnProperty(v):s[v]!==void 0)?g+=String.fromCharCode(s[v]):(y==n&&(v=u.substring(w),d=u.length),g+=String.fromCharCode(y),s[v]=y,a[y++]=v),w=d+1}return g}var n=4e4,c=o(e);n=65535;var f=o(t);return{chars1:c,chars2:f,lineArray:a}},r.prototype.diff_charsToLines_=function(e,t){for(var a=0;a<e.length;a++){for(var s=e[a][1],o=[],n=0;n<s.length;n++)o[n]=t[s.charCodeAt(n)];e[a][1]=o.join("")}},r.prototype.diff_commonPrefix=function(e,t){if(!e||!t||e.charAt(0)!=t.charAt(0))return 0;for(var a=0,s=Math.min(e.length,t.length),o=s,n=0;a<o;)e.substring(n,o)==t.substring(n,o)?(a=o,n=a):s=o,o=Math.floor((s-a)/2+a);return o},r.prototype.diff_commonSuffix=function(e,t){if(!e||!t||e.charAt(e.length-1)!=t.charAt(t.length-1))return 0;for(var a=0,s=Math.min(e.length,t.length),o=s,n=0;a<o;)e.substring(e.length-o,e.length-n)==t.substring(t.length-o,t.length-n)?(a=o,n=a):s=o,o=Math.floor((s-a)/2+a);return o},r.prototype.diff_commonOverlap_=function(e,t){var a=e.length,s=t.length;if(a==0||s==0)return 0;a>s?e=e.substring(a-s):a<s&&(t=t.substring(0,a));var o=Math.min(a,s);if(e==t)return o;for(var n=0,c=1;;){var f=e.substring(o-c),u=t.indexOf(f);if(u==-1)return n;c+=u,(u==0||e.substring(o-c)==t.substring(0,c))&&(n=c,c++)}},r.prototype.diff_halfMatch_=function(e,t){if(this.Diff_Timeout<=0)return null;var a=e.length>t.length?e:t,s=e.length>t.length?t:e;if(a.length<4||s.length*2<a.length)return null;var o=this;function n(m,_,D){for(var p=m.substring(D,D+Math.floor(m.length/4)),F=-1,H="",A,P,S,E;(F=_.indexOf(p,F+1))!=-1;){var $=o.diff_commonPrefix(m.substring(D),_.substring(F)),R=o.diff_commonSuffix(m.substring(0,D),_.substring(0,F));H.length<R+$&&(H=_.substring(F-R,F)+_.substring(F,F+$),A=m.substring(0,D-R),P=m.substring(D+$),S=_.substring(0,F-R),E=_.substring(F+$))}return H.length*2>=m.length?[A,P,S,E,H]:null}var c=n(a,s,Math.ceil(a.length/4)),f=n(a,s,Math.ceil(a.length/2)),u;if(!c&&!f)return null;f?c?u=c[4].length>f[4].length?c:f:u=f:u=c;var g,w,d,y;e.length>t.length?(g=u[0],w=u[1],d=u[2],y=u[3]):(d=u[0],y=u[1],g=u[2],w=u[3]);var v=u[4];return[g,w,d,y,v]},r.prototype.diff_cleanupSemantic=function(e){for(var t=!1,a=[],s=0,o=null,n=0,c=0,f=0,u=0,g=0;n<e.length;)e[n][0]==h?(a[s++]=n,c=u,f=g,u=0,g=0,o=e[n][1]):(e[n][0]==i?u+=e[n][1].length:g+=e[n][1].length,o&&o.length<=Math.max(c,f)&&o.length<=Math.max(u,g)&&(e.splice(a[s-1],0,new r.Diff(l,o)),e[a[s-1]+1][0]=i,s--,s--,n=s>0?a[s-1]:-1,c=0,f=0,u=0,g=0,o=null,t=!0)),n++;for(t&&this.diff_cleanupMerge(e),this.diff_cleanupSemanticLossless(e),n=1;n<e.length;){if(e[n-1][0]==l&&e[n][0]==i){var w=e[n-1][1],d=e[n][1],y=this.diff_commonOverlap_(w,d),v=this.diff_commonOverlap_(d,w);y>=v?(y>=w.length/2||y>=d.length/2)&&(e.splice(n,0,new r.Diff(h,d.substring(0,y))),e[n-1][1]=w.substring(0,w.length-y),e[n+1][1]=d.substring(y),n++):(v>=w.length/2||v>=d.length/2)&&(e.splice(n,0,new r.Diff(h,w.substring(0,v))),e[n-1][0]=i,e[n-1][1]=d.substring(0,d.length-v),e[n+1][0]=l,e[n+1][1]=w.substring(v),n++),n++}n++}},r.prototype.diff_cleanupSemanticLossless=function(e){function t(v,m){if(!v||!m)return 6;var _=v.charAt(v.length-1),D=m.charAt(0),p=_.match(r.nonAlphaNumericRegex_),F=D.match(r.nonAlphaNumericRegex_),H=p&&_.match(r.whitespaceRegex_),A=F&&D.match(r.whitespaceRegex_),P=H&&_.match(r.linebreakRegex_),S=A&&D.match(r.linebreakRegex_),E=P&&v.match(r.blanklineEndRegex_),$=S&&m.match(r.blanklineStartRegex_);return E||$?5:P||S?4:p&&!H&&A?3:H||A?2:p||F?1:0}for(var a=1;a<e.length-1;){if(e[a-1][0]==h&&e[a+1][0]==h){var s=e[a-1][1],o=e[a][1],n=e[a+1][1],c=this.diff_commonSuffix(s,o);if(c){var f=o.substring(o.length-c);s=s.substring(0,s.length-c),o=f+o.substring(0,o.length-c),n=f+n}for(var u=s,g=o,w=n,d=t(s,o)+t(o,n);o.charAt(0)===n.charAt(0);){s+=o.charAt(0),o=o.substring(1)+n.charAt(0),n=n.substring(1);var y=t(s,o)+t(o,n);y>=d&&(d=y,u=s,g=o,w=n)}e[a-1][1]!=u&&(u?e[a-1][1]=u:(e.splice(a-1,1),a--),e[a][1]=g,w?e[a+1][1]=w:(e.splice(a+1,1),a--))}a++}},r.nonAlphaNumericRegex_=/[^a-zA-Z0-9]/,r.whitespaceRegex_=/\s/,r.linebreakRegex_=/[\r\n]/,r.blanklineEndRegex_=/\n\r?\n$/,r.blanklineStartRegex_=/^\r?\n\r?\n/,r.prototype.diff_cleanupEfficiency=function(e){for(var t=!1,a=[],s=0,o=null,n=0,c=!1,f=!1,u=!1,g=!1;n<e.length;)e[n][0]==h?(e[n][1].length<this.Diff_EditCost&&(u||g)?(a[s++]=n,c=u,f=g,o=e[n][1]):(s=0,o=null),u=g=!1):(e[n][0]==l?g=!0:u=!0,o&&(c&&f&&u&&g||o.length<this.Diff_EditCost/2&&c+f+u+g==3)&&(e.splice(a[s-1],0,new r.Diff(l,o)),e[a[s-1]+1][0]=i,s--,o=null,c&&f?(u=g=!0,s=0):(s--,n=s>0?a[s-1]:-1,u=g=!1),t=!0)),n++;t&&this.diff_cleanupMerge(e)},r.prototype.diff_cleanupMerge=function(e){e.push(new r.Diff(h,""));for(var t=0,a=0,s=0,o="",n="",c;t<e.length;)switch(e[t][0]){case i:s++,n+=e[t][1],t++;break;case l:a++,o+=e[t][1],t++;break;case h:a+s>1?(a!==0&&s!==0&&(c=this.diff_commonPrefix(n,o),c!==0&&(t-a-s>0&&e[t-a-s-1][0]==h?e[t-a-s-1][1]+=n.substring(0,c):(e.splice(0,0,new r.Diff(h,n.substring(0,c))),t++),n=n.substring(c),o=o.substring(c)),c=this.diff_commonSuffix(n,o),c!==0&&(e[t][1]=n.substring(n.length-c)+e[t][1],n=n.substring(0,n.length-c),o=o.substring(0,o.length-c))),t-=a+s,e.splice(t,a+s),o.length&&(e.splice(t,0,new r.Diff(l,o)),t++),n.length&&(e.splice(t,0,new r.Diff(i,n)),t++),t++):t!==0&&e[t-1][0]==h?(e[t-1][1]+=e[t][1],e.splice(t,1)):t++,s=0,a=0,o="",n="";break}e[e.length-1][1]===""&&e.pop();var f=!1;for(t=1;t<e.length-1;)e[t-1][0]==h&&e[t+1][0]==h&&(e[t][1].substring(e[t][1].length-e[t-1][1].length)==e[t-1][1]?(e[t][1]=e[t-1][1]+e[t][1].substring(0,e[t][1].length-e[t-1][1].length),e[t+1][1]=e[t-1][1]+e[t+1][1],e.splice(t-1,1),f=!0):e[t][1].substring(0,e[t+1][1].length)==e[t+1][1]&&(e[t-1][1]+=e[t+1][1],e[t][1]=e[t][1].substring(e[t+1][1].length)+e[t+1][1],e.splice(t+1,1),f=!0)),t++;f&&this.diff_cleanupMerge(e)},r.prototype.diff_xIndex=function(e,t){var a=0,s=0,o=0,n=0,c;for(c=0;c<e.length&&(e[c][0]!==i&&(a+=e[c][1].length),e[c][0]!==l&&(s+=e[c][1].length),!(a>t));c++)o=a,n=s;return e.length!=c&&e[c][0]===l?n:n+(t-o)},r.prototype.diff_prettyHtml=function(e){for(var t=[],a=/&/g,s=/</g,o=/>/g,n=/\n/g,c=0;c<e.length;c++){var f=e[c][0],u=e[c][1],g=u.replace(a,"&amp;").replace(s,"&lt;").replace(o,"&gt;").replace(n,"&para;<br>");switch(f){case i:t[c]='<ins style="background:#e6ffe6;">'+g+"</ins>";break;case l:t[c]='<del style="background:#ffe6e6;">'+g+"</del>";break;case h:t[c]="<span>"+g+"</span>";break}}return t.join("")},r.prototype.diff_text1=function(e){for(var t=[],a=0;a<e.length;a++)e[a][0]!==i&&(t[a]=e[a][1]);return t.join("")},r.prototype.diff_text2=function(e){for(var t=[],a=0;a<e.length;a++)e[a][0]!==l&&(t[a]=e[a][1]);return t.join("")},r.prototype.diff_levenshtein=function(e){for(var t=0,a=0,s=0,o=0;o<e.length;o++){var n=e[o][0],c=e[o][1];switch(n){case i:a+=c.length;break;case l:s+=c.length;break;case h:t+=Math.max(a,s),a=0,s=0;break}}return t+=Math.max(a,s),t},r.prototype.diff_toDelta=function(e){for(var t=[],a=0;a<e.length;a++)switch(e[a][0]){case i:t[a]="+"+encodeURI(e[a][1]);break;case l:t[a]="-"+e[a][1].length;break;case h:t[a]="="+e[a][1].length;break}return t.join("	").replace(/%20/g," ")},r.prototype.diff_fromDelta=function(e,t){for(var a=[],s=0,o=0,n=t.split(/\t/g),c=0;c<n.length;c++){var f=n[c].substring(1);switch(n[c].charAt(0)){case"+":try{a[s++]=new r.Diff(i,decodeURI(f))}catch{throw new Error("Illegal escape in diff_fromDelta: "+f)}break;case"-":case"=":var u=parseInt(f,10);if(isNaN(u)||u<0)throw new Error("Invalid number in diff_fromDelta: "+f);var g=e.substring(o,o+=u);n[c].charAt(0)=="="?a[s++]=new r.Diff(h,g):a[s++]=new r.Diff(l,g);break;default:if(n[c])throw new Error("Invalid diff operation in diff_fromDelta: "+n[c])}}if(o!=e.length)throw new Error("Delta length ("+o+") does not equal source text length ("+e.length+").");return a},r.prototype.match_main=function(e,t,a){if(e==null||t==null||a==null)throw new Error("Null input. (match_main)");return a=Math.max(0,Math.min(a,e.length)),e==t?0:e.length?e.substring(a,a+t.length)==t?a:this.match_bitap_(e,t,a):-1},r.prototype.match_bitap_=function(e,t,a){if(t.length>this.Match_MaxBits)throw new Error("Pattern too long for this browser.");var s=this.match_alphabet_(t),o=this;function n(A,P){var S=A/t.length,E=Math.abs(a-P);return o.Match_Distance?S+E/o.Match_Distance:E?1:S}var c=this.Match_Threshold,f=e.indexOf(t,a);f!=-1&&(c=Math.min(n(0,f),c),f=e.lastIndexOf(t,a+t.length),f!=-1&&(c=Math.min(n(0,f),c)));var u=1<<t.length-1;f=-1;for(var g,w,d=t.length+e.length,y,v=0;v<t.length;v++){for(g=0,w=d;g<w;)n(v,a+w)<=c?g=w:d=w,w=Math.floor((d-g)/2+g);d=w;var m=Math.max(1,a-w+1),_=Math.min(a+w,e.length)+t.length,D=Array(_+2);D[_+1]=(1<<v)-1;for(var p=_;p>=m;p--){var F=s[e.charAt(p-1)];if(v===0?D[p]=(D[p+1]<<1|1)&F:D[p]=(D[p+1]<<1|1)&F|((y[p+1]|y[p])<<1|1)|y[p+1],D[p]&u){var H=n(v,p-1);if(H<=c)if(c=H,f=p-1,f>a)m=Math.max(1,2*a-f);else break}}if(n(v+1,a)>c)break;y=D}return f},r.prototype.match_alphabet_=function(e){for(var t={},a=0;a<e.length;a++)t[e.charAt(a)]=0;for(var a=0;a<e.length;a++)t[e.charAt(a)]|=1<<e.length-a-1;return t},r.prototype.patch_addContext_=function(e,t){if(t.length!=0){if(e.start2===null)throw Error("patch not initialized");for(var a=t.substring(e.start2,e.start2+e.length1),s=0;t.indexOf(a)!=t.lastIndexOf(a)&&a.length<this.Match_MaxBits-this.Patch_Margin-this.Patch_Margin;)s+=this.Patch_Margin,a=t.substring(e.start2-s,e.start2+e.length1+s);s+=this.Patch_Margin;var o=t.substring(e.start2-s,e.start2);o&&e.diffs.unshift(new r.Diff(h,o));var n=t.substring(e.start2+e.length1,e.start2+e.length1+s);n&&e.diffs.push(new r.Diff(h,n)),e.start1-=o.length,e.start2-=o.length,e.length1+=o.length+n.length,e.length2+=o.length+n.length}},r.prototype.patch_make=function(e,t,a){var s,o;if(typeof e=="string"&&typeof t=="string"&&typeof a>"u")s=e,o=this.diff_main(s,t,!0),o.length>2&&(this.diff_cleanupSemantic(o),this.diff_cleanupEfficiency(o));else if(e&&typeof e=="object"&&typeof t>"u"&&typeof a>"u")o=e,s=this.diff_text1(o);else if(typeof e=="string"&&t&&typeof t=="object"&&typeof a>"u")s=e,o=t;else if(typeof e=="string"&&typeof t=="string"&&a&&typeof a=="object")s=e,o=a;else throw new Error("Unknown call format to patch_make.");if(o.length===0)return[];for(var n=[],c=new r.patch_obj,f=0,u=0,g=0,w=s,d=s,y=0;y<o.length;y++){var v=o[y][0],m=o[y][1];switch(!f&&v!==h&&(c.start1=u,c.start2=g),v){case i:c.diffs[f++]=o[y],c.length2+=m.length,d=d.substring(0,g)+m+d.substring(g);break;case l:c.length1+=m.length,c.diffs[f++]=o[y],d=d.substring(0,g)+d.substring(g+m.length);break;case h:m.length<=2*this.Patch_Margin&&f&&o.length!=y+1?(c.diffs[f++]=o[y],c.length1+=m.length,c.length2+=m.length):m.length>=2*this.Patch_Margin&&f&&(this.patch_addContext_(c,w),n.push(c),c=new r.patch_obj,f=0,w=d,u=g);break}v!==i&&(u+=m.length),v!==l&&(g+=m.length)}return f&&(this.patch_addContext_(c,w),n.push(c)),n},r.prototype.patch_deepCopy=function(e){for(var t=[],a=0;a<e.length;a++){var s=e[a],o=new r.patch_obj;o.diffs=[];for(var n=0;n<s.diffs.length;n++)o.diffs[n]=new r.Diff(s.diffs[n][0],s.diffs[n][1]);o.start1=s.start1,o.start2=s.start2,o.length1=s.length1,o.length2=s.length2,t[a]=o}return t},r.prototype.patch_apply=function(e,t){if(e.length==0)return[t,[]];e=this.patch_deepCopy(e);var a=this.patch_addPadding(e);t=a+t+a,this.patch_splitMax(e);for(var s=0,o=[],n=0;n<e.length;n++){var c=e[n].start2+s,f=this.diff_text1(e[n].diffs),u,g=-1;if(f.length>this.Match_MaxBits?(u=this.match_main(t,f.substring(0,this.Match_MaxBits),c),u!=-1&&(g=this.match_main(t,f.substring(f.length-this.Match_MaxBits),c+f.length-this.Match_MaxBits),(g==-1||u>=g)&&(u=-1))):u=this.match_main(t,f,c),u==-1)o[n]=!1,s-=e[n].length2-e[n].length1;else{o[n]=!0,s=u-c;var w;if(g==-1?w=t.substring(u,u+f.length):w=t.substring(u,g+this.Match_MaxBits),f==w)t=t.substring(0,u)+this.diff_text2(e[n].diffs)+t.substring(u+f.length);else{var d=this.diff_main(f,w,!1);if(f.length>this.Match_MaxBits&&this.diff_levenshtein(d)/f.length>this.Patch_DeleteThreshold)o[n]=!1;else{this.diff_cleanupSemanticLossless(d);for(var y=0,v,m=0;m<e[n].diffs.length;m++){var _=e[n].diffs[m];_[0]!==h&&(v=this.diff_xIndex(d,y)),_[0]===i?t=t.substring(0,u+v)+_[1]+t.substring(u+v):_[0]===l&&(t=t.substring(0,u+v)+t.substring(u+this.diff_xIndex(d,y+_[1].length))),_[0]!==l&&(y+=_[1].length)}}}}}return t=t.substring(a.length,t.length-a.length),[t,o]},r.prototype.patch_addPadding=function(e){for(var t=this.Patch_Margin,a="",s=1;s<=t;s++)a+=String.fromCharCode(s);for(var s=0;s<e.length;s++)e[s].start1+=t,e[s].start2+=t;var o=e[0],n=o.diffs;if(n.length==0||n[0][0]!=h)n.unshift(new r.Diff(h,a)),o.start1-=t,o.start2-=t,o.length1+=t,o.length2+=t;else if(t>n[0][1].length){var c=t-n[0][1].length;n[0][1]=a.substring(n[0][1].length)+n[0][1],o.start1-=c,o.start2-=c,o.length1+=c,o.length2+=c}if(o=e[e.length-1],n=o.diffs,n.length==0||n[n.length-1][0]!=h)n.push(new r.Diff(h,a)),o.length1+=t,o.length2+=t;else if(t>n[n.length-1][1].length){var c=t-n[n.length-1][1].length;n[n.length-1][1]+=a.substring(0,c),o.length1+=c,o.length2+=c}return a},r.prototype.patch_splitMax=function(e){for(var t=this.Match_MaxBits,a=0;a<e.length;a++)if(!(e[a].length1<=t)){var s=e[a];e.splice(a--,1);for(var o=s.start1,n=s.start2,c="";s.diffs.length!==0;){var f=new r.patch_obj,u=!0;for(f.start1=o-c.length,f.start2=n-c.length,c!==""&&(f.length1=f.length2=c.length,f.diffs.push(new r.Diff(h,c)));s.diffs.length!==0&&f.length1<t-this.Patch_Margin;){var g=s.diffs[0][0],w=s.diffs[0][1];g===i?(f.length2+=w.length,n+=w.length,f.diffs.push(s.diffs.shift()),u=!1):g===l&&f.diffs.length==1&&f.diffs[0][0]==h&&w.length>2*t?(f.length1+=w.length,o+=w.length,u=!1,f.diffs.push(new r.Diff(g,w)),s.diffs.shift()):(w=w.substring(0,t-f.length1-this.Patch_Margin),f.length1+=w.length,o+=w.length,g===h?(f.length2+=w.length,n+=w.length):u=!1,f.diffs.push(new r.Diff(g,w)),w==s.diffs[0][1]?s.diffs.shift():s.diffs[0][1]=s.diffs[0][1].substring(w.length))}c=this.diff_text2(f.diffs),c=c.substring(c.length-this.Patch_Margin);var d=this.diff_text1(s.diffs).substring(0,this.Patch_Margin);d!==""&&(f.length1+=d.length,f.length2+=d.length,f.diffs.length!==0&&f.diffs[f.diffs.length-1][0]===h?f.diffs[f.diffs.length-1][1]+=d:f.diffs.push(new r.Diff(h,d))),u||e.splice(++a,0,f)}}},r.prototype.patch_toText=function(e){for(var t=[],a=0;a<e.length;a++)t[a]=e[a];return t.join("")},r.prototype.patch_fromText=function(e){var t=[];if(!e)return t;for(var a=e.split(`
`),s=0,o=/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;s<a.length;){var n=a[s].match(o);if(!n)throw new Error("Invalid patch string: "+a[s]);var c=new r.patch_obj;for(t.push(c),c.start1=parseInt(n[1],10),n[2]===""?(c.start1--,c.length1=1):n[2]=="0"?c.length1=0:(c.start1--,c.length1=parseInt(n[2],10)),c.start2=parseInt(n[3],10),n[4]===""?(c.start2--,c.length2=1):n[4]=="0"?c.length2=0:(c.start2--,c.length2=parseInt(n[4],10)),s++;s<a.length;){var f=a[s].charAt(0);try{var u=decodeURI(a[s].substring(1))}catch{throw new Error("Illegal escape in patch_fromText: "+u)}if(f=="-")c.diffs.push(new r.Diff(l,u));else if(f=="+")c.diffs.push(new r.Diff(i,u));else if(f==" ")c.diffs.push(new r.Diff(h,u));else{if(f=="@")break;if(f!=="")throw new Error('Invalid patch mode "'+f+'" in: '+u)}s++}}return t},r.patch_obj=function(){this.diffs=[],this.start1=null,this.start2=null,this.length1=0,this.length2=0},r.patch_obj.prototype.toString=function(){var e,t;this.length1===0?e=this.start1+",0":this.length1==1?e=this.start1+1:e=this.start1+1+","+this.length1,this.length2===0?t=this.start2+",0":this.length2==1?t=this.start2+1:t=this.start2+1+","+this.length2;for(var a=["@@ -"+e+" +"+t+` @@
`],s,o=0;o<this.diffs.length;o++){switch(this.diffs[o][0]){case i:s="+";break;case l:s="-";break;case h:s=" ";break}a[o+1]=s+encodeURI(this.diffs[o][1])+`
`}return a.join("").replace(/%20/g," ")},M.exports=r,M.exports.diff_match_patch=r,M.exports.DIFF_DELETE=l,M.exports.DIFF_INSERT=i,M.exports.DIFF_EQUAL=h})(L)),L.exports}var O=W();class C{constructor(){this.rules=[]}clone(){const r=new C;return r.rules=[...this.rules],r}add(r,l=""){const i=l?l.endsWith("/")?l:`${l}/`:"";r.split(/\r?\n/).forEach(h=>{if(h=h.trim(),!h||h.startsWith("#"))return;let e=h.startsWith("!");e&&(h=h.substring(1));let t=h.startsWith("/");t&&(h=h.substring(1));let a=h.replace(/[.+?^${}()|[\]\\]/g,"\\$&").replace(/\*\*/g,"__DOUBLE_WILD__").replace(/\*/g,"[^/]*").replace(/__DOUBLE_WILD__/g,".*").replace(/\?/g,".");t?a="^"+i+a:a="^"+i+"(?:.*/)?"+a,a.endsWith("/")?a+=".*":a+="($|/.*)",this.rules.push({regex:new RegExp(a),negative:e})})}ignores(r){const l=r.startsWith("/")?r.slice(1):r;let i=!1;for(const h of this.rules)h.regex.test(l)&&(i=!h.negative);return i}}const T=new O.diff_match_patch;T.Diff_EditCost=4,T.Patch_Margin=3;class z{constructor(){this.queue=[],this.active=0,this.limit=5,this.interval=100,this.lastRequestTime=0}async acquire(){const l=Date.now()-this.lastRequestTime;l<this.interval&&await new Promise(i=>setTimeout(i,this.interval-l)),this.active>=this.limit&&await new Promise(i=>this.queue.push(i)),this.active++,this.lastRequestTime=Date.now()}release(){if(this.active--,this.queue.length>0){const r=this.queue.shift();r&&r()}}}class U{constructor(r){this.active=0,this.queue=[],this.limit=r}async acquire(){if(this.active<this.limit){this.active++;return}await new Promise(r=>this.queue.push(r)),this.active++}release(){this.active--,this.queue.length>0&&this.queue.shift()()}async run(r){await this.acquire();try{return await r()}finally{this.release()}}}class j{constructor(){this.promise=Promise.resolve()}async acquire(){let r;const l=new Promise(h=>r=h),i=this.promise;return this.promise=l,await i,r}}class q{constructor(){this.locks=new Map}async acquire(r){for(;this.locks.has(r);)await this.locks.get(r);let l;const i=new Promise(h=>l=h);return this.locks.set(r,i),()=>{this.locks.delete(r),l()}}}function I(M,r){self.postMessage({id:"event",status:"fs_change",result:{type:M,path:r}})}function k(M){if(!M)return"/";M=M.replace(/\\/g,"/");const r=M.split("/").filter(e=>e!==""&&e!=="."),l=[];for(const e of r)e===".."?l.length>0&&l.pop():l.push(e);const i=l.join("/"),h=M.endsWith("/")&&l.length>0;return"/"+i+(h?"/":"")}function N(){return new Promise((M,r)=>{const l=indexedDB.open("fs_mounts",1);l.onupgradeneeded=()=>{const i=l.result;i.objectStoreNames.contains("handles")||i.createObjectStore("handles")},l.onsuccess=()=>M(l.result),l.onerror=()=>r(l.error)})}async function G(M,r){const l=await N();return new Promise((i,h)=>{const e=l.transaction("handles","readwrite");e.objectStore("handles").put(r,M),e.oncomplete=()=>i(),e.onerror=()=>h(e.error)})}async function K(){const M=await N();return new Promise((r,l)=>{const h=M.transaction("handles","readonly").objectStore("handles"),e=h.getAllKeys(),t=new Map;e.onsuccess=()=>{const a=e.result;if(a.length===0){r(t);return}let s=0;a.forEach(o=>{const n=h.get(o);n.onsuccess=()=>{t.set(o,n.result),s++,s===a.length&&r(t)}})},e.onerror=()=>l(e.error)})}async function J(M){const r=await N();return new Promise((l,i)=>{const h=r.transaction("handles","readwrite");h.objectStore("handles").delete(M),h.oncomplete=()=>l(),h.onerror=()=>i(h.error)})}function X(M){switch(M){case"image/jpeg":return".jpg";case"image/png":return".png";default:return".png"}}class Z{constructor(){this.rateLimiter=new z,this.grepLimiter=new U(20),this.listLimiter=new U(50),this.root=null,this.overlayRoot=null,this.mounts=new Map,this.githubMounts=new Map,this.githubToken=null,this.ignoreCache=new Map,this.lineIndexCache=new Map,this.INDEX_CHUNK_SIZE=64*1024,this.attributes={},this.tombstones=new Set,this.textEncoder=new TextEncoder,this.textDecoder=new TextDecoder,this.initialized=!1,this.manifestLock=new j,this.pathLocks=new q}setGithubToken(r){this.githubToken=r}async fetchGithub(r){await this.rateLimiter.acquire();try{const l={Accept:"application/vnd.github.v3+json"};this.githubToken&&(l.Authorization=`Bearer ${this.githubToken}`);const i=await fetch(r,{headers:l});if(i.status===403||i.status===429){const h=i.headers.get("x-ratelimit-reset"),e=i.headers.get("retry-after");let t=1e3;if(e)t=parseInt(e)*1e3;else if(h){const a=parseInt(h)*1e3;t=Math.max(1e3,a-Date.now())}if(t>1e4)throw new Error(`GitHub Rate Limit Exceeded. Try again in ${Math.round(t/1e3)}s.`);return await new Promise(a=>setTimeout(a,t)),fetch(r,{headers:l})}if(!i.ok)throw new Error(`GitHub API Error: ${i.statusText}`);return i}finally{this.rateLimiter.release()}}async ensureGithubTree(r){const l=this.githubMounts.get(r),i=`https://api.github.com/repos/${l.owner}/${l.repo}/git/trees/${l.branch}?recursive=1`,e=await(await this.fetchGithub(i)).json();if(e.truncated&&console.warn(`GitHub tree truncated in ${l.owner}/${l.repo} branch: ${l.branch}`),l.tree.clear(),e.tree){for(const t of e.tree)if(t.type==="blob"||t.type==="tree"){const a=`/${r}/${t.path}`;l.tree.set(t.path,{name:t.path.split("/").pop(),kind:t.type==="tree"?"directory":"file",size:t.size||0,path:a,status:"original"})}}l.treeFetched=!0}async fetchGithubContent(r,l){const i=`https://api.github.com/repos/${r.owner}/${r.repo}/contents/${l}?ref=${r.branch}`,e=await(await this.fetchGithub(i)).json();if(Array.isArray(e))throw new Error("Path is a directory");if(!e.content)return new Blob([""]);const t=atob(e.content.replace(/\n/g,"")),a=new Uint8Array(t.length);for(let s=0;s<t.length;s++)a[s]=t.charCodeAt(s);return new Blob([a])}async saveGithubMounts(){const r=await this.manifestLock.acquire();try{const h=await(await(await this.root.getDirectoryHandle(".system",{create:!0})).getFileHandle("github_mounts.json",{create:!0})).createWritable(),e=Array.from(this.githubMounts.entries()).map(([t,a])=>({alias:t,owner:a.owner,repo:a.repo,branch:a.branch}));await h.write(JSON.stringify(e)),await h.close()}finally{r()}}async saveManifest(){const r=await this.manifestLock.acquire();try{const l=await this.root.getDirectoryHandle(".system",{create:!0}),i=async(h,e)=>{const a=await(await l.getFileHandle(h,{create:!0})).createWritable();await a.write(JSON.stringify(e)),await a.close()};i("attributes.json",this.attributes),i("tombstones.json",Array.from(this.tombstones))}finally{r()}}async getLineBoundaries(r,l,i,h,e){const t=await l.getFile(),{lastModified:a,size:s}=t;let o=this.lineIndexCache.get(r);(!o||o.mtime!==a||o.size!==s)&&(o=await this.rebuildLineIndex(l,i,a,s),this.lineIndexCache.set(r,o));const n=h<=1?0:o.offsets[h-1]??s;let c=s;return e!==void 0&&(c=o.offsets[e]??s),{startOffset:n,endOffset:c,totalSize:s}}async rebuildLineIndex(r,l,i,h){const e=[0],t=new Uint8Array(this.INDEX_CHUNK_SIZE);let a=null,s=null;l==="opfs"?a=await r.createSyncAccessHandle():s=await r.getFile();try{let o=0;for(;o<h;){let n=0;if(a)n=a.read(t,{at:o});else{const c=s.slice(o,o+this.INDEX_CHUNK_SIZE),f=new Uint8Array(await c.arrayBuffer());n=f.length,t.set(f)}for(let c=0;c<n;c++)t[c]===10&&e.push(o+c+1);o+=n}return{mtime:i,size:h,offsets:new Uint32Array(e)}}finally{a==null||a.close()}}parsePath(r){const i=(r.startsWith("/")?r.slice(1):r).split("/").filter(t=>t.length>0),h=i[0],e=this.mounts.has(h)||this.githubMounts.has(h);return{parts:i,alias:e?h:null,relativeParts:e?i.slice(1):i}}async resolveForRead(r){if(await this.init(),this.tombstones.has(r))throw new Error(`Entry not found (tombstoned): ${r}`);const{alias:l,relativeParts:i,parts:h}=this.parsePath(r);if(l){const e=await this.overlayRoot.getDirectoryHandle(l,{create:!0});try{return{handle:await this.traverse(e,i,!1),source:"opfs"}}catch{}if(this.mounts.has(l)){const t=this.mounts.get(l);return{handle:await this.traverse(t,i,!1),source:"local"}}if(this.githubMounts.has(l))try{return{handle:await this.traverse(e,i,!1),source:"opfs"}}catch{const a=await this.traverse(e,i,!0),s=this.githubMounts.get(l),o=await this.fetchGithubContent(s,i.join("/")),n=await a.createSyncAccessHandle();try{const c=new Uint8Array(await o.arrayBuffer());n.write(c,{at:0}),n.flush()}finally{n.close()}return{handle:a,source:"opfs"}}}return{handle:await this.traverse(this.root,h,!1),source:"opfs"}}async resolveForWrite(r){await this.init();const{alias:l,relativeParts:i,parts:h}=this.parsePath(r);if(this.tombstones.has(r)&&(this.tombstones.delete(r),await this.saveManifest()),!l)return await this.traverse(this.root,h,!0);const e=await this.overlayRoot.getDirectoryHandle(l,{create:!0});try{return await this.traverse(e,i,!1)}catch{}const t=await this.traverse(e,i,!0);try{if(this.mounts.has(l)){const a=this.mounts.get(l),n=(await(await this.traverse(a,i,!1)).getFile()).stream().getReader(),c=await t.createSyncAccessHandle();try{let f=0;for(;;){const{done:u,value:g}=await n.read();if(u)break;c.write(g,{at:f}),f+=g.length}c.flush()}finally{c.close()}}else if(this.githubMounts.has(l)){const a=this.githubMounts.get(l);try{const s=await this.fetchGithubContent(a,i.join("/")),o=await t.createSyncAccessHandle();try{const n=new Uint8Array(await s.arrayBuffer());o.write(n,{at:0}),o.flush()}finally{o.close()}}catch{}}}catch{}return t}async present(r,l){if(l.length===0)return!0;let i=r;const h=l[l.length-1];try{for(let e=0;e<l.length-1;e++)i=await i.getDirectoryHandle(l[e],{create:!0});await i.getFileHandle(h)}catch{try{await i.getDirectoryHandle(h)}catch{return!1}}return!0}async traverse(r,l,i){if(l.length===0)return r;let h=r;for(let t=0;t<l.length-1;t++)h=await h.getDirectoryHandle(l[t],{create:i});const e=l[l.length-1];if(i)return await h.getFileHandle(e,{create:i});try{return await h.getFileHandle(e)}catch{try{return await h.getDirectoryHandle(e)}catch{throw new Error(`Path not found: ${l.join("/")}`)}}}filterTombstones(r){return r.filter(l=>!this.tombstones.has(l.path))}async meta(r,l,i){let h=0,e=0;if(r.kind==="file"){const t=await r.getFile();h=t.size,e=t.lastModified}return{name:r.name,kind:r.kind,path:l,size:h,lastModified:e,status:i}}async removeOverlayFile(r,l){try{const i=await this.overlayRoot.getDirectoryHandle(r),h=[];let e=i;const t=l[l.length-1],a=l.slice(0,-1);for(const s of a)h.push({name:s,handle:e}),e=await e.getDirectoryHandle(s);if(await e.removeEntry(t,{recursive:!0}),await this.isDirectoryEmpty(e)){let s=a[a.length-1];for(let o=h.length-1;o>=0;o--){const n=h[o];if(await n.handle.removeEntry(s,{recursive:!0}),o>0&&await this.isDirectoryEmpty(n.handle)){s=n.name;continue}else break}}}catch{}}async isDirectoryEmpty(r){for await(const l of r.keys())return!1;return!0}async getFilesRecursively(r,l=""){const i=[];for await(const[h,e]of r.entries()){const t=l?`${l}/${h}`:h;e.kind==="file"?i.push(t):i.push(...await this.getFilesRecursively(e,t))}return i}generateUnifiedDiff(r,l,i,h){const e=r?r.split(/\r?\n/):[],t=l?l.split(/\r?\n/):[],a=i.startsWith("/")?i.slice(1):i;let s=[];if(h==="new file")return s.push("--- /dev/null"),s.push(`+++ ${a}`),s.push(`@@ -0,0 +1,${t.length} @@`),t.forEach(f=>s.push(`+${f}`)),s.join(`
`);if(h==="deleted")return s.push(`--- ${a}`),s.push("+++ /dev/null"),s.push(`@@ -1,${e.length} +0,0 @@`),e.forEach(f=>s.push(`-${f}`)),s.join(`
`);const o=T.diff_main(r||"",l||"");T.diff_cleanupSemantic(o);const n=T.patch_make(r||"",o),c=T.patch_toText(n);return c.trim()?`--- a/${a}
+++ b/${a}
${decodeURIComponent(c)}`:""}async readGitIgnore(r,l){try{const i=this.mounts.get(r);if(i){let h=i;if(l)for(const a of l.split("/"))h=await h.getDirectoryHandle(a);return await(await(await h.getFileHandle(".gitignore")).getFile()).text()}}catch{}return null}async getScopedMatcher(r,l){const i=`${r}:${l}`;if(this.ignoreCache.has(i))return this.ignoreCache.get(i);if(l===""||l==="."){const o=new C;o.add(".git/");const n=await this.readGitIgnore(r,"");return n&&o.add(n,""),this.ignoreCache.set(i,o),o}const e=l.split("/").slice(0,-1).join("/"),a=(await this.getScopedMatcher(r,e)).clone(),s=await this.readGitIgnore(r,l);return s&&a.add(s,l),this.ignoreCache.set(i,a),a}invalidateIgnoreCache(r){for(const l of this.ignoreCache.keys())l.startsWith(`${r}:`)&&this.ignoreCache.delete(l)}async init(){if(this.initialized)return;const r=await this.manifestLock.acquire();try{if(this.initialized)return;this.root=await navigator.storage.getDirectory(),this.overlayRoot=await this.root.getDirectoryHandle(".overlay",{create:!0}),await this.root.getDirectoryHandle("images",{create:!0});const l=await this.root.getDirectoryHandle(".system",{create:!0});try{const h=await(await l.getFileHandle("attributes.json")).getFile();this.attributes=JSON.parse(await h.text())}catch{this.attributes={}}try{const h=await(await l.getFileHandle("tombstones.json")).getFile(),e=JSON.parse(await h.text());this.tombstones=new Set(e)}catch{this.tombstones=new Set}try{const h=await(await l.getFileHandle("github_mounts.json")).getFile();JSON.parse(await h.text()).forEach(t=>{this.githubMounts.set(t.alias,{owner:t.owner,repo:t.repo,branch:t.branch,tree:new Map,treeFetched:!1})})}catch{}try{const i=await K();for(const[h,e]of i)this.mounts.set(h,e)}catch(i){console.error("Failed to load local mounts",i)}this.initialized=!0}finally{r()}}async mount(r,l){if(r===".system"||r===".overlay"||r==="images")throw new Error(`Mount ${r} is reserved`);if(await this.init(),this.mounts.has(r)||this.githubMounts.has(r))throw new Error(`Mount ${r} already in use`);return await G(r,l),this.mounts.set(r,l),!0}async mountGithub(r,l,i,h){if(r===".system"||r===".overlay"||r==="images")throw new Error(`Mount ${r} is reserved`);if(await this.init(),this.mounts.has(r)||this.githubMounts.has(r))throw new Error(`Mount ${r} already in use`);return this.githubMounts.set(r,{owner:l,repo:i,branch:h,tree:new Map,treeFetched:!1}),await this.saveGithubMounts(),!0}async unmount(r){const l=`/${r}/`;for(const i of Object.keys(this.attributes))i.startsWith(l)&&delete this.attributes[i];return this.mounts.has(r)&&(this.mounts.delete(r),await J(r)),this.githubMounts.has(r)&&(this.githubMounts.delete(r),await this.saveGithubMounts()),this.delete(".overlay/"+r),this.tombstones=new Set(Array.from(this.tombstones).filter(i=>!i.startsWith(r))),this.invalidateIgnoreCache(r),await this.saveManifest(),!0}async getMountInfo(r){if(await this.init(),this.githubMounts.has(r)){const l=this.githubMounts.get(r);return{type:"github",owner:l.owner,repo:l.repo,branch:l.branch}}return this.mounts.has(r)?{type:"local"}:null}async getMounts(){return await this.init(),[...Array.from(this.mounts.keys()),...Array.from(this.githubMounts.keys())]}async flushFile(r){await this.init();const l=await this.pathLocks.acquire(r);try{const{alias:i,relativeParts:h}=this.parsePath(r);if(!i)throw new Error("Cannot flush: Path is not part of a mounted workspace.");const e=this.mounts.get(i);if(!e)throw new Error("Mount point not found.");if(this.tombstones.has(r)){try{const u=h.slice(0,-1),g=h[h.length-1];let w=e;for(const d of u)w=await w.getDirectoryHandle(d);await w.removeEntry(g,{recursive:!0}),this.tombstones.delete(r),await this.saveManifest()}catch(u){console.warn(`Failed to delete local file (maybe already gone?) ${r}`,u)}return}let t;try{const u=await this.overlayRoot.getDirectoryHandle(i);t=await this.traverse(u,h,!1)}catch{throw new Error("Nothing to flush: File has no pending changes in overlay.")}const s=await(await t.getFile()).arrayBuffer();let o=e;for(let u=0;u<h.length-1;u++)o=await o.getDirectoryHandle(h[u],{create:!0});const n=h[h.length-1],f=await(await o.getFileHandle(n,{create:!0})).createWritable();await f.write(s),await f.close(),await this.removeOverlayFile(i,h),I("write",r)}finally{l()}}async flushMount(r){if(await this.init(),!this.mounts.has(r))throw new Error("Unknown mount alias");try{const h=await this.overlayRoot.getDirectoryHandle(r),e=await this.getFilesRecursively(h);for(const t of e){const a=`/${r}/${t}`;await this.flushFile(a)}}catch{}const l=`/${r}/`,i=Array.from(this.tombstones).filter(h=>h.startsWith(l));for(const h of i)await this.flushFile(h)}async discardChange(r){await this.init();const{alias:l,relativeParts:i}=this.parsePath(r);l&&(this.tombstones.has(r)&&(this.tombstones.delete(r),await this.saveManifest()),await this.removeOverlayFile(l,i),I("write",r))}async diff(r){await this.init();const{alias:l,relativeParts:i}=this.parsePath(r);if(!l)throw new Error("Diff is only supported for mounted files.");const h=this.tombstones.has(r);let e="",t="",a=!1,s=!1;try{const o=this.mounts.get(l);e=await(await(await this.traverse(o,i,!1)).getFile()).text(),a=!0}catch{}if(h)s=!1;else try{const o=await this.overlayRoot.getDirectoryHandle(l);t=await(await(await this.traverse(o,i,!1)).getFile()).text(),s=!0}catch{if(a)return""}return!a&&!s?"":!a&&s?this.generateUnifiedDiff(null,t,r,"new file"):a&&!s?h?this.generateUnifiedDiff(e,null,r,"deleted"):"":this.generateUnifiedDiff(e,t,r)}async addTags(r,l){await this.init();const i=await this.pathLocks.acquire(r);try{this.attributes[r]||(this.attributes[r]={tags:[]});const h=new Set(this.attributes[r].tags);l.forEach(e=>h.add(e)),this.attributes[r].tags=Array.from(h),await this.saveManifest(),I("tags_change",r)}finally{i()}}async removeTags(r,l){await this.init();const i=await this.pathLocks.acquire(r);try{this.attributes[r]&&(this.attributes[r].tags=this.attributes[r].tags.filter(h=>!l.includes(h)),await this.saveManifest(),I("tags_change",r))}finally{i()}}async searchByTags(r){await this.init();const l=[];for(const[i,h]of Object.entries(this.attributes))r.every(e=>h.tags.includes(e))&&l.push(i);return l}async getTags(r){var i;await this.init();const l=await this.pathLocks.acquire(r);try{return((i=this.attributes[r])==null?void 0:i.tags)||[]}finally{l()}}async list(r="/",l=!1){await this.init();let i=[];const{alias:h,relativeParts:e}=this.parsePath(r);if(r==="/"){for(const t of this.mounts.keys())i.push({name:t,kind:"directory",path:`/${t}`,size:0,status:"original"});for(const t of this.githubMounts.keys())i.push({name:t,kind:"directory",path:`/${t}`,size:0,status:"original"});for await(const[t,a]of this.root.entries())(!l||!t.startsWith("."))&&i.push(await this.meta(a,`/${t}`,"original"));return this.filterTombstones(i)}if(h){const t=new Map,a=e.join("/"),s=await this.getScopedMatcher(h,a),o=n=>{const c=a?`${a}/${n}`:n;return s.ignores(c)};try{if(this.mounts.has(h)){let n=this.mounts.get(h);for(const c of e)n=await n.getDirectoryHandle(c);for await(const[c,f]of n.entries())o(c)||t.set(c,await this.meta(f,`${r}/${c}`,"original"))}else if(this.githubMounts.has(h)){const n=this.githubMounts.get(h);await this.ensureGithubTree(h);const c=a?a+"/":"";for(const[f,u]of n.tree.entries())if(f.startsWith(c)){const g=f.slice(c.length);g&&!g.includes("/")&&(o(u.name)||t.set(u.name,{...u,path:`${r}/${u.name}`}))}}}catch(n){return console.error(`Failed to list files in ${r}`,n),[]}try{let n=await this.overlayRoot.getDirectoryHandle(h);for(const c of e)n=await n.getDirectoryHandle(c);for await(const[c,f]of n.entries())if(!o(c)){const u=t.has(c)?"modified":"new";t.set(c,await this.meta(f,`${r}/${c}`,u))}}catch{}i=Array.from(t.values())}else try{const t=await this.traverse(this.root,this.parsePath(r).parts,!1);for await(const[a,s]of t.entries())i.push(await this.meta(s,`${r}/${a}`,"original"))}catch{return[]}return this.filterTombstones(i)}async getMetadata(r){if(await this.init(),this.tombstones.has(r))throw new Error("ENOENT");try{const{handle:l,source:i}=await this.resolveForRead(r),{alias:h}=this.parsePath(r),e=i==="local"?"original":h?"modified":"original";return await this.meta(l,r,e)}catch{throw new Error("ENOENT")}}async listRecursive(r="/",l=!1){const i=await this.listLimiter.run(()=>this.list(r,l));return(await Promise.all(i.map(async e=>e.kind==="directory"?[e,...await this.listRecursive(e.path)]:[e]))).flat()}async listRecursiveTree(r="/",l=!1){const i={kind:"directory",path:r,children:{}},h=await this.listLimiter.run(()=>this.list(r,l));return await Promise.all(h.map(async e=>{e.kind==="file"?i.children[e.name]=e:i.children[e.name]=await this.listRecursiveTree(e.path,l)})),i}async write(r,l){const i=await this.pathLocks.acquire(r);try{const e=await(await this.resolveForWrite(r)).createSyncAccessHandle();try{const t=typeof l=="string"?this.textEncoder.encode(l):l;if(e.truncate(0),e.write(t,{at:0}),e.flush(),r.endsWith(".gitignore")){const{alias:a}=this.parsePath(r);a&&this.invalidateIgnoreCache(a)}I("write",r)}finally{e.close(),this.lineIndexCache.delete(r)}}finally{i()}}async applyPatch(r,l){const i=T.patch_fromText(l);if(i.length===0)throw Error("No valid patches found in content");const h=await this.pathLocks.acquire(r);try{const t=await(await this.resolveForWrite(r)).createSyncAccessHandle();try{const a=t.getSize();let s=new Uint8Array(a);t.read(s,{at:0});let o=new TextDecoder().decode(s);s=null;let[n,c]=T.patch_apply(i,o);o=null;const f=c.filter(g=>g===!0).length;if(c.every(g=>g===!0)){let g=this.textEncoder.encode(n);n=null,t.write(g,{at:0}),t.truncate(g.length),g=null,t.flush(),this.lineIndexCache.delete(r),I("write",r)}else{const g=c.map((w,d)=>w?null:d+1).filter(w=>w!==null);throw new Error(`Patch failed: ${c.length-f} of ${c.length} hunks failed to apply. Failed hunks: #${g.join(", #")}. No changes were written to the file. Please re-read the file to ensure your patch context is up-to-date.`)}}finally{t.close()}}finally{h()}}async append(r,l){const i=await this.pathLocks.acquire(r);try{const e=await(await this.resolveForWrite(r)).createSyncAccessHandle();try{const t=typeof l=="string"?this.textEncoder.encode(l+`
`):l,a=e.getSize();e.write(t,{at:a}),e.flush(),I("write",r)}finally{e.close(),this.lineIndexCache.delete(r)}}finally{i()}}async replaceRange(r,l,i,h,e,t){await this.init();const a=(await this.readWindow(r,l,l)).trim(),s=(await this.readWindow(r,i,i)).trim();if(e&&a!==e.trim())throw new Error(`Safety Mismatch at start line ${l}.
Expected: "${e.trim()}"
Actual:   "${a.trim()}"`);if(t&&s!==t.trim())throw new Error(`Safety Mismatch at end line ${i}.
Expected: "${t.trim()}"
Actual:   "${s.trim()}"`);const o=await this.pathLocks.acquire(r);try{const n=await this.resolveForWrite(r),{startOffset:c,endOffset:f,totalSize:u}=await this.getLineBoundaries(r,n,"opfs",l,i),g=crypto.randomUUID(),w=await this.root.getDirectoryHandle(".system",{create:!0}),d=await w.getFileHandle(`swap_${g}.tmp`,{create:!0}),y=await n.createSyncAccessHandle(),v=await d.createSyncAccessHandle();try{c>0&&await this.streamCopy(y,v,0,c,0);const m=D=>{let p;typeof D=="string"?p=this.textEncoder.encode(D):p=D,v.write(p,{at:v.getSize()})};if(typeof h=="string")m(h);else for(let D of h)m(D);const _=u-f;_>0&&await this.streamCopy(y,v,f,_,v.getSize()),y.truncate(v.getSize()),await this.streamCopy(v,y,0,v.getSize(),0),I("write",r)}finally{y.close(),v.close(),await w.removeEntry(`swap_${g}.tmp`)}}finally{o()}}async readWindow(r,l,i){const h=await this.pathLocks.acquire(r);try{const{handle:e,source:t}=await this.resolveForRead(r),{startOffset:a,endOffset:s}=await this.getLineBoundaries(r,e,t,l,i);return a>=s?"":await(await e.getFile()).slice(a,s).text()}finally{h()}}async grep(r,l={}){await this.init();const h=(await this.listRecursive("/")).filter(t=>{var a,s,o;return!(t.kind!=="file"||(a=l.paths)!=null&&a.length&&!l.paths.includes(t.path)||(s=l.include_paths)!=null&&s.length&&!l.include_paths.some(n=>t.path.includes(n))||(o=l.exclude_paths)!=null&&o.length&&l.exclude_paths.some(n=>t.path.includes(n)))});return(await Promise.all(h.map(async t=>this.grepLimiter.run(async()=>[...await this.grepFile(t.path,r)])))).flat()}async grepFile(r,l){const i=await this.pathLocks.acquire(r);try{const{handle:h}=await this.resolveForRead(r),t=(await h.getFile()).stream().getReader(),a=[];let s=1,o="";for(;;){const{done:n,value:c}=await t.read();if(n)break;const f=this.textDecoder.decode(c,{stream:!0}),u=(o+f).split(/\r?\n/);o=u.pop()||"";for(const g of u)g.includes(l)&&a.push({line:s,content:g.trim()}),s++}return o.includes(l)&&(s++,a.push({line:s,content:o.trim()})),a}finally{i()}}async delete(r){await this.init();const l=await this.pathLocks.acquire(r);try{await this._delete(r)}finally{l()}}async _delete(r){for(const e of Object.keys(this.attributes))(e===r||e.startsWith(r+"/"))&&delete this.attributes[e];const{alias:l,relativeParts:i,parts:h}=this.parsePath(r);if(l){this.tombstones.add(r),await this.saveManifest();try{let e=await this.overlayRoot.getDirectoryHandle(l);const t=i.pop();for(const a of i)e=await e.getDirectoryHandle(a);await e.removeEntry(t,{recursive:!0})}catch{}}else{const e=h.slice(0,-1),t=h[h.length-1];let a=this.root;for(const s of e)a=await a.getDirectoryHandle(s);await a.removeEntry(t,{recursive:!0})}if(this.attributes[r]&&delete this.attributes[r],r.endsWith("/.gitignore")){const{alias:e}=this.parsePath(r);e&&this.invalidateIgnoreCache(e)}await this.saveManifest(),I("delete",r)}async countLines(r){const l=await this.pathLocks.acquire(r);try{const{handle:i,source:h}=await this.resolveForRead(r);let e=0;if(h==="opfs"){const t=await i.createSyncAccessHandle();try{const a=t.getSize();if(a===0)return 0;const s=new Uint8Array(64*1024);let o=0;for(;o<a;){const n=t.read(s,{at:o});for(let c=0;c<n;c++)s[c]===10&&e++;o+=n}}finally{t.close()}}else{const t=await i.getFile();if(t.size===0)return 0;const a=t.stream().getReader();for(;;){const{done:s,value:o}=await a.read();if(s)break;for(let n=0;n<o.length;n++)o[n]===10&&e++}}return e+1}finally{l()}}async readFile(r){const{handle:l}=await this.resolveForRead(r);return l.getFile()}async readBytes(r,l,i){const{handle:h,source:e}=await this.resolveForRead(r);if(e==="opfs"){const t=await h.createSyncAccessHandle();try{const a=new Uint8Array(i),s=t.read(a,{at:l});return a.subarray(0,s)}finally{t.close()}}else{const s=await(await h.getFile()).slice(l,l+i).arrayBuffer();return new Uint8Array(s)}}async writeBytes(r,l,i){const h=await this.pathLocks.acquire(r);try{const t=await(await this.resolveForWrite(r)).createSyncAccessHandle();try{const a=t.write(l,{at:i});return t.flush(),a}finally{t.close()}}finally{h()}}async truncate(r,l){const i=await this.pathLocks.acquire(r);try{const e=await(await this.resolveForWrite(r)).createSyncAccessHandle();try{e.truncate(l),e.flush()}finally{e.close(),this.lineIndexCache.delete(r)}}finally{i()}}async streamCopy(r,l,i,h,e){const a=new Uint8Array(65536);let s=h,o=i,n=e??l.getSize();for(;s>0;){const c=r.read(a.subarray(0,Math.min(65536,s)),{at:o});if(c===0)break;l.write(a.subarray(0,c),{at:n}),o+=c,n+=c,s-=c}}async rename(r,l){const i=[r,l].sort(),h=await this.pathLocks.acquire(i[0]),e=await this.pathLocks.acquire(i[1]);try{const t=await this.resolveForWrite(r),a=await this.resolveForWrite(l),s=await t.createSyncAccessHandle(),o=await a.createSyncAccessHandle();try{const n=s.getSize();o.truncate(0),await this.streamCopy(s,o,0,n,0),o.flush()}finally{s.close(),o.close()}this.attributes[r]&&(this.attributes[l]={...this.attributes[r]}),await this._delete(r)}finally{e(),h()}}async mkdir(r){await this.init();const{alias:l,relativeParts:i,parts:h}=this.parsePath(r),e=await this.pathLocks.acquire(r);try{if(this.tombstones.has(r)&&(this.tombstones.delete(r),await this.saveManifest()),l){let a=await this.overlayRoot.getDirectoryHandle(l,{create:!0});for(const s of i)a=await a.getDirectoryHandle(s,{create:!0})}else{let t=this.root;for(const a of h)t=await t.getDirectoryHandle(a,{create:!0})}I("write",r)}finally{e()}}async storeImage(r,l){const i=`/images/${crypto.randomUUID()+X(r)}`;return await this.write(i,l),i}}const b=new Z;self.onmessage=async M=>{const{id:r,method:l,args:i}=M.data;try{let h;switch(l){case"mount":h=await b.mount(i.alias,i.handle);break;case"mountGithub":h=await b.mountGithub(i.alias,i.owner,i.repo,i.branch);break;case"setGithubToken":h=await b.setGithubToken(i.token);break;case"getMounts":h=await b.getMounts();break;case"getMountInfo":h=await b.getMountInfo(i.alias);break;case"unmount":h=await b.unmount(i.alias);break;case"flushFile":h=await b.flushFile(k(i.path));break;case"flushMount":h=await b.flushMount(i.alias);break;case"discardChange":h=await b.discardChange(k(i.path));break;case"diff":h=await b.diff(k(i.path));break;case"addTags":h=await b.addTags(k(i.path),i.tags);break;case"removeTags":h=await b.removeTags(k(i.path),i.tags);break;case"searchByTags":h=await b.searchByTags(i.tags);break;case"getTags":h=await b.getTags(k(i.path));break;case"getMetadata":h=await b.getMetadata(k(i.path));break;case"list":h=await b.list(k(i.path),i.ignoreSystem);break;case"listRecursive":h=await b.listRecursive(k(i.path),i.ignoreSystem);break;case"listRecursiveTree":h=await b.listRecursiveTree(k(i.path),i.ignoreSystem);break;case"write":h=await b.write(k(i.path),i.content);break;case"applyPatch":h=await b.applyPatch(k(i.path),i.content);break;case"replaceRange":h=await b.replaceRange(k(i.path),i.startLine,i.endLine,i.newContent,i.expectedStart,i.expectedEnd);break;case"append":h=await b.append(k(i.path),i.content);break;case"readWindow":h=await b.readWindow(k(i.path),i.startLine,i.endLine);break;case"grep":h=await b.grep(i.query,i.options);break;case"grepFile":h=await b.grepFile(k(i.path),i.query);break;case"delete":h=await b.delete(k(i.path));break;case"countLines":h=await b.countLines(k(i.path));break;case"readFile":h=await b.readFile(k(i.path));break;case"readBytes":h=await b.readBytes(k(i.path),i.offset,i.length);break;case"writeBytes":h=await b.writeBytes(k(i.path),i.buffer,i.offset);break;case"truncate":h=await b.truncate(k(i.path),i.size);break;case"rename":h=await b.rename(k(i.oldPath),k(i.newPath));break;case"mkdir":h=await b.mkdir(k(i.path));break;case"storeImage":h=await b.storeImage(i.mimeType,i.data);break;default:throw new Error(`Unknown method: ${l}`)}self.postMessage({id:r,status:"success",result:h})}catch(h){self.postMessage({id:r,status:"error",error:h.message})}}})();
