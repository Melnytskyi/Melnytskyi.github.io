(function(){"use strict";var R={exports:{}},C;function B(){return C||(C=1,(function(D){var r=function(){this.Diff_Timeout=1,this.Diff_EditCost=4,this.Match_Threshold=.5,this.Match_Distance=1e3,this.Patch_DeleteThreshold=.5,this.Patch_Margin=4,this.Match_MaxBits=32},c=-1,i=1,o=0;r.Diff=function(t,e){return[t,e]},r.prototype.diff_main=function(t,e,a,s){typeof s>"u"&&(this.Diff_Timeout<=0?s=Number.MAX_VALUE:s=new Date().getTime()+this.Diff_Timeout*1e3);var l=s;if(t==null||e==null)throw new Error("Null input. (diff_main)");if(t==e)return t?[new r.Diff(o,t)]:[];typeof a>"u"&&(a=!0);var n=a,h=this.diff_commonPrefix(t,e),f=t.substring(0,h);t=t.substring(h),e=e.substring(h),h=this.diff_commonSuffix(t,e);var u=t.substring(t.length-h);t=t.substring(0,t.length-h),e=e.substring(0,e.length-h);var g=this.diff_compute_(t,e,n,l);return f&&g.unshift(new r.Diff(o,f)),u&&g.push(new r.Diff(o,u)),this.diff_cleanupMerge(g),g},r.prototype.diff_compute_=function(t,e,a,s){var l;if(!t)return[new r.Diff(i,e)];if(!e)return[new r.Diff(c,t)];var n=t.length>e.length?t:e,h=t.length>e.length?e:t,f=n.indexOf(h);if(f!=-1)return l=[new r.Diff(i,n.substring(0,f)),new r.Diff(o,h),new r.Diff(i,n.substring(f+h.length))],t.length>e.length&&(l[0][0]=l[2][0]=c),l;if(h.length==1)return[new r.Diff(c,t),new r.Diff(i,e)];var u=this.diff_halfMatch_(t,e);if(u){var g=u[0],w=u[1],d=u[2],v=u[3],m=u[4],y=this.diff_main(g,d,a,s),_=this.diff_main(w,v,a,s);return y.concat([new r.Diff(o,m)],_)}return a&&t.length>100&&e.length>100?this.diff_lineMode_(t,e,s):this.diff_bisect_(t,e,s)},r.prototype.diff_lineMode_=function(t,e,a){var s=this.diff_linesToChars_(t,e);t=s.chars1,e=s.chars2;var l=s.lineArray,n=this.diff_main(t,e,!1,a);this.diff_charsToLines_(n,l),this.diff_cleanupSemantic(n),n.push(new r.Diff(o,""));for(var h=0,f=0,u=0,g="",w="";h<n.length;){switch(n[h][0]){case i:u++,w+=n[h][1];break;case c:f++,g+=n[h][1];break;case o:if(f>=1&&u>=1){n.splice(h-f-u,f+u),h=h-f-u;for(var d=this.diff_main(g,w,!1,a),v=d.length-1;v>=0;v--)n.splice(h,0,d[v]);h=h+d.length}u=0,f=0,g="",w="";break}h++}return n.pop(),n},r.prototype.diff_bisect_=function(t,e,a){for(var s=t.length,l=e.length,n=Math.ceil((s+l)/2),h=n,f=2*n,u=new Array(f),g=new Array(f),w=0;w<f;w++)u[w]=-1,g[w]=-1;u[h+1]=0,g[h+1]=0;for(var d=s-l,v=d%2!=0,m=0,y=0,_=0,k=0,b=0;b<n&&!(new Date().getTime()>a);b++){for(var M=-b+m;M<=b-y;M+=2){var F=h+M,P;M==-b||M!=b&&u[F-1]<u[F+1]?P=u[F+1]:P=u[F-1]+1;for(var E=P-M;P<s&&E<l&&t.charAt(P)==e.charAt(E);)P++,E++;if(u[F]=P,P>s)y+=2;else if(E>l)m+=2;else if(v){var A=h+d-M;if(A>=0&&A<f&&g[A]!=-1){var H=s-g[A];if(P>=H)return this.diff_bisectSplit_(t,e,P,E,a)}}}for(var S=-b+_;S<=b-k;S+=2){var A=h+S,H;S==-b||S!=b&&g[A-1]<g[A+1]?H=g[A+1]:H=g[A-1]+1;for(var z=H-S;H<s&&z<l&&t.charAt(s-H-1)==e.charAt(l-z-1);)H++,z++;if(g[A]=H,H>s)k+=2;else if(z>l)_+=2;else if(!v){var F=h+d-S;if(F>=0&&F<f&&u[F]!=-1){var P=u[F],E=h+P-F;if(H=s-H,P>=H)return this.diff_bisectSplit_(t,e,P,E,a)}}}}return[new r.Diff(c,t),new r.Diff(i,e)]},r.prototype.diff_bisectSplit_=function(t,e,a,s,l){var n=t.substring(0,a),h=e.substring(0,s),f=t.substring(a),u=e.substring(s),g=this.diff_main(n,h,!1,l),w=this.diff_main(f,u,!1,l);return g.concat(w)},r.prototype.diff_linesToChars_=function(t,e){var a=[],s={};a[0]="";function l(u){for(var g="",w=0,d=-1,v=a.length;d<u.length-1;){d=u.indexOf(`
`,w),d==-1&&(d=u.length-1);var m=u.substring(w,d+1);(s.hasOwnProperty?s.hasOwnProperty(m):s[m]!==void 0)?g+=String.fromCharCode(s[m]):(v==n&&(m=u.substring(w),d=u.length),g+=String.fromCharCode(v),s[m]=v,a[v++]=m),w=d+1}return g}var n=4e4,h=l(t);n=65535;var f=l(e);return{chars1:h,chars2:f,lineArray:a}},r.prototype.diff_charsToLines_=function(t,e){for(var a=0;a<t.length;a++){for(var s=t[a][1],l=[],n=0;n<s.length;n++)l[n]=e[s.charCodeAt(n)];t[a][1]=l.join("")}},r.prototype.diff_commonPrefix=function(t,e){if(!t||!e||t.charAt(0)!=e.charAt(0))return 0;for(var a=0,s=Math.min(t.length,e.length),l=s,n=0;a<l;)t.substring(n,l)==e.substring(n,l)?(a=l,n=a):s=l,l=Math.floor((s-a)/2+a);return l},r.prototype.diff_commonSuffix=function(t,e){if(!t||!e||t.charAt(t.length-1)!=e.charAt(e.length-1))return 0;for(var a=0,s=Math.min(t.length,e.length),l=s,n=0;a<l;)t.substring(t.length-l,t.length-n)==e.substring(e.length-l,e.length-n)?(a=l,n=a):s=l,l=Math.floor((s-a)/2+a);return l},r.prototype.diff_commonOverlap_=function(t,e){var a=t.length,s=e.length;if(a==0||s==0)return 0;a>s?t=t.substring(a-s):a<s&&(e=e.substring(0,a));var l=Math.min(a,s);if(t==e)return l;for(var n=0,h=1;;){var f=t.substring(l-h),u=e.indexOf(f);if(u==-1)return n;h+=u,(u==0||t.substring(l-h)==e.substring(0,h))&&(n=h,h++)}},r.prototype.diff_halfMatch_=function(t,e){if(this.Diff_Timeout<=0)return null;var a=t.length>e.length?t:e,s=t.length>e.length?e:t;if(a.length<4||s.length*2<a.length)return null;var l=this;function n(y,_,k){for(var b=y.substring(k,k+Math.floor(y.length/4)),M=-1,F="",P,E,A,H;(M=_.indexOf(b,M+1))!=-1;){var S=l.diff_commonPrefix(y.substring(k),_.substring(M)),z=l.diff_commonSuffix(y.substring(0,k),_.substring(0,M));F.length<z+S&&(F=_.substring(M-z,M)+_.substring(M,M+S),P=y.substring(0,k-z),E=y.substring(k+S),A=_.substring(0,M-z),H=_.substring(M+S))}return F.length*2>=y.length?[P,E,A,H,F]:null}var h=n(a,s,Math.ceil(a.length/4)),f=n(a,s,Math.ceil(a.length/2)),u;if(!h&&!f)return null;f?h?u=h[4].length>f[4].length?h:f:u=f:u=h;var g,w,d,v;t.length>e.length?(g=u[0],w=u[1],d=u[2],v=u[3]):(d=u[0],v=u[1],g=u[2],w=u[3]);var m=u[4];return[g,w,d,v,m]},r.prototype.diff_cleanupSemantic=function(t){for(var e=!1,a=[],s=0,l=null,n=0,h=0,f=0,u=0,g=0;n<t.length;)t[n][0]==o?(a[s++]=n,h=u,f=g,u=0,g=0,l=t[n][1]):(t[n][0]==i?u+=t[n][1].length:g+=t[n][1].length,l&&l.length<=Math.max(h,f)&&l.length<=Math.max(u,g)&&(t.splice(a[s-1],0,new r.Diff(c,l)),t[a[s-1]+1][0]=i,s--,s--,n=s>0?a[s-1]:-1,h=0,f=0,u=0,g=0,l=null,e=!0)),n++;for(e&&this.diff_cleanupMerge(t),this.diff_cleanupSemanticLossless(t),n=1;n<t.length;){if(t[n-1][0]==c&&t[n][0]==i){var w=t[n-1][1],d=t[n][1],v=this.diff_commonOverlap_(w,d),m=this.diff_commonOverlap_(d,w);v>=m?(v>=w.length/2||v>=d.length/2)&&(t.splice(n,0,new r.Diff(o,d.substring(0,v))),t[n-1][1]=w.substring(0,w.length-v),t[n+1][1]=d.substring(v),n++):(m>=w.length/2||m>=d.length/2)&&(t.splice(n,0,new r.Diff(o,w.substring(0,m))),t[n-1][0]=i,t[n-1][1]=d.substring(0,d.length-m),t[n+1][0]=c,t[n+1][1]=w.substring(m),n++),n++}n++}},r.prototype.diff_cleanupSemanticLossless=function(t){function e(m,y){if(!m||!y)return 6;var _=m.charAt(m.length-1),k=y.charAt(0),b=_.match(r.nonAlphaNumericRegex_),M=k.match(r.nonAlphaNumericRegex_),F=b&&_.match(r.whitespaceRegex_),P=M&&k.match(r.whitespaceRegex_),E=F&&_.match(r.linebreakRegex_),A=P&&k.match(r.linebreakRegex_),H=E&&m.match(r.blanklineEndRegex_),S=A&&y.match(r.blanklineStartRegex_);return H||S?5:E||A?4:b&&!F&&P?3:F||P?2:b||M?1:0}for(var a=1;a<t.length-1;){if(t[a-1][0]==o&&t[a+1][0]==o){var s=t[a-1][1],l=t[a][1],n=t[a+1][1],h=this.diff_commonSuffix(s,l);if(h){var f=l.substring(l.length-h);s=s.substring(0,s.length-h),l=f+l.substring(0,l.length-h),n=f+n}for(var u=s,g=l,w=n,d=e(s,l)+e(l,n);l.charAt(0)===n.charAt(0);){s+=l.charAt(0),l=l.substring(1)+n.charAt(0),n=n.substring(1);var v=e(s,l)+e(l,n);v>=d&&(d=v,u=s,g=l,w=n)}t[a-1][1]!=u&&(u?t[a-1][1]=u:(t.splice(a-1,1),a--),t[a][1]=g,w?t[a+1][1]=w:(t.splice(a+1,1),a--))}a++}},r.nonAlphaNumericRegex_=/[^a-zA-Z0-9]/,r.whitespaceRegex_=/\s/,r.linebreakRegex_=/[\r\n]/,r.blanklineEndRegex_=/\n\r?\n$/,r.blanklineStartRegex_=/^\r?\n\r?\n/,r.prototype.diff_cleanupEfficiency=function(t){for(var e=!1,a=[],s=0,l=null,n=0,h=!1,f=!1,u=!1,g=!1;n<t.length;)t[n][0]==o?(t[n][1].length<this.Diff_EditCost&&(u||g)?(a[s++]=n,h=u,f=g,l=t[n][1]):(s=0,l=null),u=g=!1):(t[n][0]==c?g=!0:u=!0,l&&(h&&f&&u&&g||l.length<this.Diff_EditCost/2&&h+f+u+g==3)&&(t.splice(a[s-1],0,new r.Diff(c,l)),t[a[s-1]+1][0]=i,s--,l=null,h&&f?(u=g=!0,s=0):(s--,n=s>0?a[s-1]:-1,u=g=!1),e=!0)),n++;e&&this.diff_cleanupMerge(t)},r.prototype.diff_cleanupMerge=function(t){t.push(new r.Diff(o,""));for(var e=0,a=0,s=0,l="",n="",h;e<t.length;)switch(t[e][0]){case i:s++,n+=t[e][1],e++;break;case c:a++,l+=t[e][1],e++;break;case o:a+s>1?(a!==0&&s!==0&&(h=this.diff_commonPrefix(n,l),h!==0&&(e-a-s>0&&t[e-a-s-1][0]==o?t[e-a-s-1][1]+=n.substring(0,h):(t.splice(0,0,new r.Diff(o,n.substring(0,h))),e++),n=n.substring(h),l=l.substring(h)),h=this.diff_commonSuffix(n,l),h!==0&&(t[e][1]=n.substring(n.length-h)+t[e][1],n=n.substring(0,n.length-h),l=l.substring(0,l.length-h))),e-=a+s,t.splice(e,a+s),l.length&&(t.splice(e,0,new r.Diff(c,l)),e++),n.length&&(t.splice(e,0,new r.Diff(i,n)),e++),e++):e!==0&&t[e-1][0]==o?(t[e-1][1]+=t[e][1],t.splice(e,1)):e++,s=0,a=0,l="",n="";break}t[t.length-1][1]===""&&t.pop();var f=!1;for(e=1;e<t.length-1;)t[e-1][0]==o&&t[e+1][0]==o&&(t[e][1].substring(t[e][1].length-t[e-1][1].length)==t[e-1][1]?(t[e][1]=t[e-1][1]+t[e][1].substring(0,t[e][1].length-t[e-1][1].length),t[e+1][1]=t[e-1][1]+t[e+1][1],t.splice(e-1,1),f=!0):t[e][1].substring(0,t[e+1][1].length)==t[e+1][1]&&(t[e-1][1]+=t[e+1][1],t[e][1]=t[e][1].substring(t[e+1][1].length)+t[e+1][1],t.splice(e+1,1),f=!0)),e++;f&&this.diff_cleanupMerge(t)},r.prototype.diff_xIndex=function(t,e){var a=0,s=0,l=0,n=0,h;for(h=0;h<t.length&&(t[h][0]!==i&&(a+=t[h][1].length),t[h][0]!==c&&(s+=t[h][1].length),!(a>e));h++)l=a,n=s;return t.length!=h&&t[h][0]===c?n:n+(e-l)},r.prototype.diff_prettyHtml=function(t){for(var e=[],a=/&/g,s=/</g,l=/>/g,n=/\n/g,h=0;h<t.length;h++){var f=t[h][0],u=t[h][1],g=u.replace(a,"&amp;").replace(s,"&lt;").replace(l,"&gt;").replace(n,"&para;<br>");switch(f){case i:e[h]='<ins style="background:#e6ffe6;">'+g+"</ins>";break;case c:e[h]='<del style="background:#ffe6e6;">'+g+"</del>";break;case o:e[h]="<span>"+g+"</span>";break}}return e.join("")},r.prototype.diff_text1=function(t){for(var e=[],a=0;a<t.length;a++)t[a][0]!==i&&(e[a]=t[a][1]);return e.join("")},r.prototype.diff_text2=function(t){for(var e=[],a=0;a<t.length;a++)t[a][0]!==c&&(e[a]=t[a][1]);return e.join("")},r.prototype.diff_levenshtein=function(t){for(var e=0,a=0,s=0,l=0;l<t.length;l++){var n=t[l][0],h=t[l][1];switch(n){case i:a+=h.length;break;case c:s+=h.length;break;case o:e+=Math.max(a,s),a=0,s=0;break}}return e+=Math.max(a,s),e},r.prototype.diff_toDelta=function(t){for(var e=[],a=0;a<t.length;a++)switch(t[a][0]){case i:e[a]="+"+encodeURI(t[a][1]);break;case c:e[a]="-"+t[a][1].length;break;case o:e[a]="="+t[a][1].length;break}return e.join("	").replace(/%20/g," ")},r.prototype.diff_fromDelta=function(t,e){for(var a=[],s=0,l=0,n=e.split(/\t/g),h=0;h<n.length;h++){var f=n[h].substring(1);switch(n[h].charAt(0)){case"+":try{a[s++]=new r.Diff(i,decodeURI(f))}catch{throw new Error("Illegal escape in diff_fromDelta: "+f)}break;case"-":case"=":var u=parseInt(f,10);if(isNaN(u)||u<0)throw new Error("Invalid number in diff_fromDelta: "+f);var g=t.substring(l,l+=u);n[h].charAt(0)=="="?a[s++]=new r.Diff(o,g):a[s++]=new r.Diff(c,g);break;default:if(n[h])throw new Error("Invalid diff operation in diff_fromDelta: "+n[h])}}if(l!=t.length)throw new Error("Delta length ("+l+") does not equal source text length ("+t.length+").");return a},r.prototype.match_main=function(t,e,a){if(t==null||e==null||a==null)throw new Error("Null input. (match_main)");return a=Math.max(0,Math.min(a,t.length)),t==e?0:t.length?t.substring(a,a+e.length)==e?a:this.match_bitap_(t,e,a):-1},r.prototype.match_bitap_=function(t,e,a){if(e.length>this.Match_MaxBits)throw new Error("Pattern too long for this browser.");var s=this.match_alphabet_(e),l=this;function n(P,E){var A=P/e.length,H=Math.abs(a-E);return l.Match_Distance?A+H/l.Match_Distance:H?1:A}var h=this.Match_Threshold,f=t.indexOf(e,a);f!=-1&&(h=Math.min(n(0,f),h),f=t.lastIndexOf(e,a+e.length),f!=-1&&(h=Math.min(n(0,f),h)));var u=1<<e.length-1;f=-1;for(var g,w,d=e.length+t.length,v,m=0;m<e.length;m++){for(g=0,w=d;g<w;)n(m,a+w)<=h?g=w:d=w,w=Math.floor((d-g)/2+g);d=w;var y=Math.max(1,a-w+1),_=Math.min(a+w,t.length)+e.length,k=Array(_+2);k[_+1]=(1<<m)-1;for(var b=_;b>=y;b--){var M=s[t.charAt(b-1)];if(m===0?k[b]=(k[b+1]<<1|1)&M:k[b]=(k[b+1]<<1|1)&M|((v[b+1]|v[b])<<1|1)|v[b+1],k[b]&u){var F=n(m,b-1);if(F<=h)if(h=F,f=b-1,f>a)y=Math.max(1,2*a-f);else break}}if(n(m+1,a)>h)break;v=k}return f},r.prototype.match_alphabet_=function(t){for(var e={},a=0;a<t.length;a++)e[t.charAt(a)]=0;for(var a=0;a<t.length;a++)e[t.charAt(a)]|=1<<t.length-a-1;return e},r.prototype.patch_addContext_=function(t,e){if(e.length!=0){if(t.start2===null)throw Error("patch not initialized");for(var a=e.substring(t.start2,t.start2+t.length1),s=0;e.indexOf(a)!=e.lastIndexOf(a)&&a.length<this.Match_MaxBits-this.Patch_Margin-this.Patch_Margin;)s+=this.Patch_Margin,a=e.substring(t.start2-s,t.start2+t.length1+s);s+=this.Patch_Margin;var l=e.substring(t.start2-s,t.start2);l&&t.diffs.unshift(new r.Diff(o,l));var n=e.substring(t.start2+t.length1,t.start2+t.length1+s);n&&t.diffs.push(new r.Diff(o,n)),t.start1-=l.length,t.start2-=l.length,t.length1+=l.length+n.length,t.length2+=l.length+n.length}},r.prototype.patch_make=function(t,e,a){var s,l;if(typeof t=="string"&&typeof e=="string"&&typeof a>"u")s=t,l=this.diff_main(s,e,!0),l.length>2&&(this.diff_cleanupSemantic(l),this.diff_cleanupEfficiency(l));else if(t&&typeof t=="object"&&typeof e>"u"&&typeof a>"u")l=t,s=this.diff_text1(l);else if(typeof t=="string"&&e&&typeof e=="object"&&typeof a>"u")s=t,l=e;else if(typeof t=="string"&&typeof e=="string"&&a&&typeof a=="object")s=t,l=a;else throw new Error("Unknown call format to patch_make.");if(l.length===0)return[];for(var n=[],h=new r.patch_obj,f=0,u=0,g=0,w=s,d=s,v=0;v<l.length;v++){var m=l[v][0],y=l[v][1];switch(!f&&m!==o&&(h.start1=u,h.start2=g),m){case i:h.diffs[f++]=l[v],h.length2+=y.length,d=d.substring(0,g)+y+d.substring(g);break;case c:h.length1+=y.length,h.diffs[f++]=l[v],d=d.substring(0,g)+d.substring(g+y.length);break;case o:y.length<=2*this.Patch_Margin&&f&&l.length!=v+1?(h.diffs[f++]=l[v],h.length1+=y.length,h.length2+=y.length):y.length>=2*this.Patch_Margin&&f&&(this.patch_addContext_(h,w),n.push(h),h=new r.patch_obj,f=0,w=d,u=g);break}m!==i&&(u+=y.length),m!==c&&(g+=y.length)}return f&&(this.patch_addContext_(h,w),n.push(h)),n},r.prototype.patch_deepCopy=function(t){for(var e=[],a=0;a<t.length;a++){var s=t[a],l=new r.patch_obj;l.diffs=[];for(var n=0;n<s.diffs.length;n++)l.diffs[n]=new r.Diff(s.diffs[n][0],s.diffs[n][1]);l.start1=s.start1,l.start2=s.start2,l.length1=s.length1,l.length2=s.length2,e[a]=l}return e},r.prototype.patch_apply=function(t,e){if(t.length==0)return[e,[]];t=this.patch_deepCopy(t);var a=this.patch_addPadding(t);e=a+e+a,this.patch_splitMax(t);for(var s=0,l=[],n=0;n<t.length;n++){var h=t[n].start2+s,f=this.diff_text1(t[n].diffs),u,g=-1;if(f.length>this.Match_MaxBits?(u=this.match_main(e,f.substring(0,this.Match_MaxBits),h),u!=-1&&(g=this.match_main(e,f.substring(f.length-this.Match_MaxBits),h+f.length-this.Match_MaxBits),(g==-1||u>=g)&&(u=-1))):u=this.match_main(e,f,h),u==-1)l[n]=!1,s-=t[n].length2-t[n].length1;else{l[n]=!0,s=u-h;var w;if(g==-1?w=e.substring(u,u+f.length):w=e.substring(u,g+this.Match_MaxBits),f==w)e=e.substring(0,u)+this.diff_text2(t[n].diffs)+e.substring(u+f.length);else{var d=this.diff_main(f,w,!1);if(f.length>this.Match_MaxBits&&this.diff_levenshtein(d)/f.length>this.Patch_DeleteThreshold)l[n]=!1;else{this.diff_cleanupSemanticLossless(d);for(var v=0,m,y=0;y<t[n].diffs.length;y++){var _=t[n].diffs[y];_[0]!==o&&(m=this.diff_xIndex(d,v)),_[0]===i?e=e.substring(0,u+m)+_[1]+e.substring(u+m):_[0]===c&&(e=e.substring(0,u+m)+e.substring(u+this.diff_xIndex(d,v+_[1].length))),_[0]!==c&&(v+=_[1].length)}}}}}return e=e.substring(a.length,e.length-a.length),[e,l]},r.prototype.patch_addPadding=function(t){for(var e=this.Patch_Margin,a="",s=1;s<=e;s++)a+=String.fromCharCode(s);for(var s=0;s<t.length;s++)t[s].start1+=e,t[s].start2+=e;var l=t[0],n=l.diffs;if(n.length==0||n[0][0]!=o)n.unshift(new r.Diff(o,a)),l.start1-=e,l.start2-=e,l.length1+=e,l.length2+=e;else if(e>n[0][1].length){var h=e-n[0][1].length;n[0][1]=a.substring(n[0][1].length)+n[0][1],l.start1-=h,l.start2-=h,l.length1+=h,l.length2+=h}if(l=t[t.length-1],n=l.diffs,n.length==0||n[n.length-1][0]!=o)n.push(new r.Diff(o,a)),l.length1+=e,l.length2+=e;else if(e>n[n.length-1][1].length){var h=e-n[n.length-1][1].length;n[n.length-1][1]+=a.substring(0,h),l.length1+=h,l.length2+=h}return a},r.prototype.patch_splitMax=function(t){for(var e=this.Match_MaxBits,a=0;a<t.length;a++)if(!(t[a].length1<=e)){var s=t[a];t.splice(a--,1);for(var l=s.start1,n=s.start2,h="";s.diffs.length!==0;){var f=new r.patch_obj,u=!0;for(f.start1=l-h.length,f.start2=n-h.length,h!==""&&(f.length1=f.length2=h.length,f.diffs.push(new r.Diff(o,h)));s.diffs.length!==0&&f.length1<e-this.Patch_Margin;){var g=s.diffs[0][0],w=s.diffs[0][1];g===i?(f.length2+=w.length,n+=w.length,f.diffs.push(s.diffs.shift()),u=!1):g===c&&f.diffs.length==1&&f.diffs[0][0]==o&&w.length>2*e?(f.length1+=w.length,l+=w.length,u=!1,f.diffs.push(new r.Diff(g,w)),s.diffs.shift()):(w=w.substring(0,e-f.length1-this.Patch_Margin),f.length1+=w.length,l+=w.length,g===o?(f.length2+=w.length,n+=w.length):u=!1,f.diffs.push(new r.Diff(g,w)),w==s.diffs[0][1]?s.diffs.shift():s.diffs[0][1]=s.diffs[0][1].substring(w.length))}h=this.diff_text2(f.diffs),h=h.substring(h.length-this.Patch_Margin);var d=this.diff_text1(s.diffs).substring(0,this.Patch_Margin);d!==""&&(f.length1+=d.length,f.length2+=d.length,f.diffs.length!==0&&f.diffs[f.diffs.length-1][0]===o?f.diffs[f.diffs.length-1][1]+=d:f.diffs.push(new r.Diff(o,d))),u||t.splice(++a,0,f)}}},r.prototype.patch_toText=function(t){for(var e=[],a=0;a<t.length;a++)e[a]=t[a];return e.join("")},r.prototype.patch_fromText=function(t){var e=[];if(!t)return e;for(var a=t.split(`
`),s=0,l=/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;s<a.length;){var n=a[s].match(l);if(!n)throw new Error("Invalid patch string: "+a[s]);var h=new r.patch_obj;for(e.push(h),h.start1=parseInt(n[1],10),n[2]===""?(h.start1--,h.length1=1):n[2]=="0"?h.length1=0:(h.start1--,h.length1=parseInt(n[2],10)),h.start2=parseInt(n[3],10),n[4]===""?(h.start2--,h.length2=1):n[4]=="0"?h.length2=0:(h.start2--,h.length2=parseInt(n[4],10)),s++;s<a.length;){var f=a[s].charAt(0);try{var u=decodeURI(a[s].substring(1))}catch{throw new Error("Illegal escape in patch_fromText: "+u)}if(f=="-")h.diffs.push(new r.Diff(c,u));else if(f=="+")h.diffs.push(new r.Diff(i,u));else if(f==" ")h.diffs.push(new r.Diff(o,u));else{if(f=="@")break;if(f!=="")throw new Error('Invalid patch mode "'+f+'" in: '+u)}s++}}return e},r.patch_obj=function(){this.diffs=[],this.start1=null,this.start2=null,this.length1=0,this.length2=0},r.patch_obj.prototype.toString=function(){var t,e;this.length1===0?t=this.start1+",0":this.length1==1?t=this.start1+1:t=this.start1+1+","+this.length1,this.length2===0?e=this.start2+",0":this.length2==1?e=this.start2+1:e=this.start2+1+","+this.length2;for(var a=["@@ -"+t+" +"+e+` @@
`],s,l=0;l<this.diffs.length;l++){switch(this.diffs[l][0]){case i:s="+";break;case c:s="-";break;case o:s=" ";break}a[l+1]=s+encodeURI(this.diffs[l][1])+`
`}return a.join("").replace(/%20/g," ")},D.exports=r,D.exports.diff_match_patch=r,D.exports.DIFF_DELETE=c,D.exports.DIFF_INSERT=i,D.exports.DIFF_EQUAL=o})(R)),R.exports}var O=B();class L{constructor(){this.rules=[]}clone(){const r=new L;return r.rules=[...this.rules],r}add(r,c=""){const i=c?c.endsWith("/")?c:`${c}/`:"";r.split(/\r?\n/).forEach(o=>{if(o=o.trim(),!o||o.startsWith("#"))return;let t=o.startsWith("!");t&&(o=o.substring(1));let e=o.startsWith("/");e&&(o=o.substring(1));let a=o.replace(/[.+?^${}()|[\]\\]/g,"\\$&").replace(/\*\*/g,"__DOUBLE_WILD__").replace(/\*/g,"[^/]*").replace(/__DOUBLE_WILD__/g,".*").replace(/\?/g,".");e?a="^"+i+a:a="^"+i+"(?:.*/)?"+a,a.endsWith("/")?a+=".*":a+="($|/.*)",this.rules.push({regex:new RegExp(a),negative:t})})}ignores(r){const c=r.startsWith("/")?r.slice(1):r;let i=!1;for(const o of this.rules)o.regex.test(c)&&(i=!o.negative);return i}}const I=new O.diff_match_patch;I.Diff_EditCost=4,I.Patch_Margin=3;class U{constructor(){this.queue=[],this.active=0,this.limit=5,this.interval=100,this.lastRequestTime=0}async acquire(){const c=Date.now()-this.lastRequestTime;c<this.interval&&await new Promise(i=>setTimeout(i,this.interval-c)),this.active>=this.limit&&await new Promise(i=>this.queue.push(i)),this.active++,this.lastRequestTime=Date.now()}release(){if(this.active--,this.queue.length>0){const r=this.queue.shift();r&&r()}}}class N{constructor(r){this.active=0,this.queue=[],this.limit=r}async acquire(){if(this.active<this.limit){this.active++;return}await new Promise(r=>this.queue.push(r)),this.active++}release(){this.active--,this.queue.length>0&&this.queue.shift()()}async run(r){await this.acquire();try{return await r()}finally{this.release()}}}class W{constructor(){this.promise=Promise.resolve()}async acquire(){let r;const c=new Promise(o=>r=o),i=this.promise;return this.promise=c,await i,r}}class q{constructor(){this.locks=new Map}async acquire(r){for(;this.locks.has(r);)await this.locks.get(r);let c;const i=new Promise(o=>c=o);return this.locks.set(r,i),()=>{this.locks.delete(r),c()}}}function $(D,r){self.postMessage({id:"event",status:"fs_change",result:{type:D,path:r}})}function T(){return new Promise((D,r)=>{const c=indexedDB.open("fs_mounts",1);c.onupgradeneeded=()=>{const i=c.result;i.objectStoreNames.contains("handles")||i.createObjectStore("handles")},c.onsuccess=()=>D(c.result),c.onerror=()=>r(c.error)})}async function j(D,r){const c=await T();return new Promise((i,o)=>{const t=c.transaction("handles","readwrite");t.objectStore("handles").put(r,D),t.oncomplete=()=>i(),t.onerror=()=>o(t.error)})}async function G(){const D=await T();return new Promise((r,c)=>{const o=D.transaction("handles","readonly").objectStore("handles"),t=o.getAllKeys(),e=new Map;t.onsuccess=()=>{const a=t.result;if(a.length===0){r(e);return}let s=0;a.forEach(l=>{const n=o.get(l);n.onsuccess=()=>{e.set(l,n.result),s++,s===a.length&&r(e)}})},t.onerror=()=>c(t.error)})}async function K(D){const r=await T();return new Promise((c,i)=>{const o=r.transaction("handles","readwrite");o.objectStore("handles").delete(D),o.oncomplete=()=>c(),o.onerror=()=>i(o.error)})}function J(D){switch(D){case"image/jpeg":return".jpg";case"image/png":return".png";default:return".png"}}class X{constructor(){this.rateLimiter=new U,this.grepLimiter=new N(20),this.listLimiter=new N(50),this.root=null,this.overlayRoot=null,this.mounts=new Map,this.githubMounts=new Map,this.githubToken=null,this.ignoreCache=new Map,this.lineIndexCache=new Map,this.INDEX_CHUNK_SIZE=64*1024,this.attributes={},this.tombstones=new Set,this.textEncoder=new TextEncoder,this.textDecoder=new TextDecoder,this.initialized=!1,this.manifestLock=new W,this.pathLocks=new q}setGithubToken(r){this.githubToken=r}async fetchGithub(r){await this.rateLimiter.acquire();try{const c={Accept:"application/vnd.github.v3+json"};this.githubToken&&(c.Authorization=`Bearer ${this.githubToken}`);const i=await fetch(r,{headers:c});if(i.status===403||i.status===429){const o=i.headers.get("x-ratelimit-reset"),t=i.headers.get("retry-after");let e=1e3;if(t)e=parseInt(t)*1e3;else if(o){const a=parseInt(o)*1e3;e=Math.max(1e3,a-Date.now())}if(e>1e4)throw new Error(`GitHub Rate Limit Exceeded. Try again in ${Math.round(e/1e3)}s.`);return await new Promise(a=>setTimeout(a,e)),fetch(r,{headers:c})}if(!i.ok)throw new Error(`GitHub API Error: ${i.statusText}`);return i}finally{this.rateLimiter.release()}}async ensureGithubTree(r){const c=this.githubMounts.get(r);if(c||console.log("mount is not init"+r),c.treeFetched||console.log("nount is fetched"+r),!c||c.treeFetched)return;console.log("mount proceed init "+r);const i=`https://api.github.com/repos/${c.owner}/${c.repo}/git/trees/${c.branch}?recursive=1`,t=await(await this.fetchGithub(i)).json();if(t.truncated&&console.warn("GitHub tree truncated"),c.tree.clear(),t.tree){for(const e of t.tree)if(e.type==="blob"||e.type==="tree"){const a=`/${r}/${e.path}`;c.tree.set(e.path,{name:e.path.split("/").pop(),kind:e.type==="tree"?"directory":"file",size:e.size||0,path:a,status:"original"})}}c.treeFetched=!0}async fetchGithubContent(r,c){const i=`https://api.github.com/repos/${r.owner}/${r.repo}/contents/${c}?ref=${r.branch}`,t=await(await this.fetchGithub(i)).json();if(Array.isArray(t))throw new Error("Path is a directory");if(!t.content)return new Blob([""]);const e=atob(t.content.replace(/\n/g,"")),a=new Uint8Array(e.length);for(let s=0;s<e.length;s++)a[s]=e.charCodeAt(s);return new Blob([a])}async saveGithubMounts(){const r=await this.manifestLock.acquire();try{const o=await(await(await this.root.getDirectoryHandle(".system",{create:!0})).getFileHandle("github_mounts.json",{create:!0})).createWritable(),t=Array.from(this.githubMounts.entries()).map(([e,a])=>({alias:e,owner:a.owner,repo:a.repo,branch:a.branch}));await o.write(JSON.stringify(t)),await o.close()}finally{r()}}async saveManifest(){const r=await this.manifestLock.acquire();try{const c=await this.root.getDirectoryHandle(".system",{create:!0}),i=async(o,t)=>{const a=await(await c.getFileHandle(o,{create:!0})).createWritable();await a.write(JSON.stringify(t)),await a.close()};i("attributes.json",this.attributes),i("tombstones.json",Array.from(this.tombstones))}finally{r()}}async getLineBoundaries(r,c,i,o,t){const e=await c.getFile(),{lastModified:a,size:s}=e;let l=this.lineIndexCache.get(r);(!l||l.mtime!==a||l.size!==s)&&(l=await this.rebuildLineIndex(c,i,a,s),this.lineIndexCache.set(r,l));const n=o<=1?0:l.offsets[o-1]??s;let h=s;return t!==void 0&&(h=l.offsets[t]??s),{startOffset:n,endOffset:h,totalSize:s}}async rebuildLineIndex(r,c,i,o){const t=[0],e=new Uint8Array(this.INDEX_CHUNK_SIZE);let a=null,s=null;c==="opfs"?a=await r.createSyncAccessHandle():s=await r.getFile();try{let l=0;for(;l<o;){let n=0;if(a)n=a.read(e,{at:l});else{const h=s.slice(l,l+this.INDEX_CHUNK_SIZE),f=new Uint8Array(await h.arrayBuffer());n=f.length,e.set(f)}for(let h=0;h<n;h++)e[h]===10&&t.push(l+h+1);l+=n}return{mtime:i,size:o,offsets:new Uint32Array(t)}}finally{a==null||a.close()}}normalizePath(r){return r.startsWith("/")?r:`/${r}`}parsePath(r){const i=(r.startsWith("/")?r.slice(1):r).split("/").filter(e=>e.length>0),o=i[0],t=this.mounts.has(o)||this.githubMounts.has(o);return{parts:i,alias:t?o:null,relativeParts:t?i.slice(1):i}}async resolveForRead(r){await this.init();const c=this.normalizePath(r);if(this.tombstones.has(c))throw new Error(`Entry not found (tombstoned): ${r}`);const{alias:i,relativeParts:o,parts:t}=this.parsePath(c);if(i){const e=await this.overlayRoot.getDirectoryHandle(i,{create:!0});try{return{handle:await this.traverse(e,o,!1),source:"opfs"}}catch{}if(this.mounts.has(i)){const a=this.mounts.get(i);return{handle:await this.traverse(a,o,!1),source:"local"}}if(this.githubMounts.has(i))try{return{handle:await this.traverse(e,o,!1),source:"opfs"}}catch{const s=await this.traverse(e,o,!0),l=this.githubMounts.get(i),n=await this.fetchGithubContent(l,o.join("/")),h=await s.createSyncAccessHandle();try{const f=new Uint8Array(await n.arrayBuffer());h.write(f,{at:0}),h.flush()}finally{h.close()}return{handle:s,source:"opfs"}}}return{handle:await this.traverse(this.root,t,!1),source:"opfs"}}async resolveForWrite(r){await this.init();const c=this.normalizePath(r),{alias:i,relativeParts:o,parts:t}=this.parsePath(r);if(this.tombstones.has(c)&&(this.tombstones.delete(c),await this.saveManifest()),!i)return await this.traverse(this.root,t,!0);const e=await this.overlayRoot.getDirectoryHandle(i,{create:!0});try{return await this.traverse(e,o,!1)}catch{}const a=await this.traverse(e,o,!0);try{if(this.mounts.has(i)){const s=this.mounts.get(i),h=(await(await this.traverse(s,o,!1)).getFile()).stream().getReader(),f=await a.createSyncAccessHandle();try{let u=0;for(;;){const{done:g,value:w}=await h.read();if(g)break;f.write(w,{at:u}),u+=w.length}f.flush()}finally{f.close()}}else if(this.githubMounts.has(i)){const s=this.githubMounts.get(i);try{const l=await this.fetchGithubContent(s,o.join("/")),n=await a.createSyncAccessHandle();try{const h=new Uint8Array(await l.arrayBuffer());n.write(h,{at:0}),n.flush()}finally{n.close()}}catch{}}}catch{}return a}async present(r,c){if(c.length===0)return!0;let i=r;const o=c[c.length-1];try{for(let t=0;t<c.length-1;t++)i=await i.getDirectoryHandle(c[t],{create:!0});await i.getFileHandle(o)}catch{try{await i.getDirectoryHandle(o)}catch{return!1}}return!0}async traverse(r,c,i){if(c.length===0)return r;let o=r;for(let e=0;e<c.length-1;e++)o=await o.getDirectoryHandle(c[e],{create:i});const t=c[c.length-1];if(i)return await o.getFileHandle(t,{create:i});try{return await o.getFileHandle(t)}catch{try{return await o.getDirectoryHandle(t)}catch{throw new Error(`Path not found: ${c.join("/")}`)}}}filterTombstones(r){return r.filter(c=>!this.tombstones.has(this.normalizePath(c.path)))}async meta(r,c,i){let o=0,t=0;if(r.kind==="file"){const e=await r.getFile();o=e.size,t=e.lastModified}return{name:r.name,kind:r.kind,path:c,size:o,lastModified:t,status:i}}async removeOverlayFile(r,c){try{const i=await this.overlayRoot.getDirectoryHandle(r),o=[];let t=i;const e=c[c.length-1],a=c.slice(0,-1);for(const s of a)o.push({name:s,handle:t}),t=await t.getDirectoryHandle(s);if(await t.removeEntry(e,{recursive:!0}),await this.isDirectoryEmpty(t)){let s=a[a.length-1];for(let l=o.length-1;l>=0;l--){const n=o[l];if(await n.handle.removeEntry(s,{recursive:!0}),l>0&&await this.isDirectoryEmpty(n.handle)){s=n.name;continue}else break}}}catch{}}async isDirectoryEmpty(r){for await(const c of r.keys())return!1;return!0}async getFilesRecursively(r,c=""){const i=[];for await(const[o,t]of r.entries()){const e=c?`${c}/${o}`:o;t.kind==="file"?i.push(e):i.push(...await this.getFilesRecursively(t,e))}return i}generateUnifiedDiff(r,c,i,o){const t=r?r.split(/\r?\n/):[],e=c?c.split(/\r?\n/):[],a=i.startsWith("/")?i.slice(1):i;let s=[];if(o==="new file")return s.push("--- /dev/null"),s.push(`+++ ${a}`),s.push(`@@ -0,0 +1,${e.length} @@`),e.forEach(f=>s.push(`+${f}`)),s.join(`
`);if(o==="deleted")return s.push(`--- ${a}`),s.push("+++ /dev/null"),s.push(`@@ -1,${t.length} +0,0 @@`),t.forEach(f=>s.push(`-${f}`)),s.join(`
`);const l=I.diff_main(r||"",c||"");I.diff_cleanupSemantic(l);const n=I.patch_make(r||"",l),h=I.patch_toText(n);return h.trim()?`--- a/${a}
+++ b/${a}
${decodeURIComponent(h)}`:""}async readGitIgnore(r,c){try{const i=this.mounts.get(r);if(i){let o=i;if(c)for(const a of c.split("/"))o=await o.getDirectoryHandle(a);return await(await(await o.getFileHandle(".gitignore")).getFile()).text()}}catch{}return null}async getScopedMatcher(r,c){const i=`${r}:${c}`;if(this.ignoreCache.has(i))return this.ignoreCache.get(i);if(c===""||c==="."){const l=new L;l.add(".git/");const n=await this.readGitIgnore(r,"");return n&&l.add(n,""),this.ignoreCache.set(i,l),l}const o=c.split("/"),t=o.slice(0,-1).join("/");o[o.length-1];const a=(await this.getScopedMatcher(r,t)).clone(),s=await this.readGitIgnore(r,c);return s&&a.add(s,c),this.ignoreCache.set(i,a),a}invalidateIgnoreCache(r){for(const c of this.ignoreCache.keys())c.startsWith(`${r}:`)&&this.ignoreCache.delete(c)}async init(){if(this.initialized)return;const r=await this.manifestLock.acquire();try{if(this.initialized)return;this.root=await navigator.storage.getDirectory(),this.overlayRoot=await this.root.getDirectoryHandle(".overlay",{create:!0}),await this.root.getDirectoryHandle("images",{create:!0});const c=await this.root.getDirectoryHandle(".system",{create:!0});try{const o=await(await c.getFileHandle("attributes.json")).getFile();this.attributes=JSON.parse(await o.text())}catch{this.attributes={}}try{const o=await(await c.getFileHandle("tombstones.json")).getFile(),t=JSON.parse(await o.text());this.tombstones=new Set(t)}catch{this.tombstones=new Set}try{const o=await(await c.getFileHandle("github_mounts.json")).getFile();JSON.parse(await o.text()).forEach(e=>{this.githubMounts.set(e.alias,{owner:e.owner,repo:e.repo,branch:e.branch,tree:new Map,treeFetched:!1})})}catch{}try{const i=await G();for(const[o,t]of i)this.mounts.set(o,t)}catch(i){console.error("Failed to load local mounts",i)}this.initialized=!0}finally{r()}}async mount(r,c){if(r===".system"||r===".overlay"||r==="images")throw new Error(`Mount ${r} is reserved`);if(await this.init(),this.mounts.has(r)||this.githubMounts.has(r))throw new Error(`Mount ${r} already in use`);return await j(r,c),this.mounts.set(r,c),!0}async mountGithub(r,c,i,o){if(r===".system"||r===".overlay"||r==="images")throw new Error(`Mount ${r} is reserved`);if(await this.init(),this.mounts.has(r)||this.githubMounts.has(r))throw new Error(`Mount ${r} already in use`);return this.githubMounts.set(r,{owner:c,repo:i,branch:o,tree:new Map,treeFetched:!1}),await this.saveGithubMounts(),!0}async unmount(r){const c=`/${r}/`;for(const i of Object.keys(this.attributes))i.startsWith(c)&&delete this.attributes[i];return this.mounts.has(r)&&(this.mounts.delete(r),await K(r)),this.githubMounts.has(r)&&(this.githubMounts.delete(r),await this.saveGithubMounts()),this.delete(".overlay/"+r),this.tombstones=new Set(Array.from(this.tombstones).filter(i=>!i.startsWith(r))),this.invalidateIgnoreCache(r),await this.saveManifest(),!0}async getMountInfo(r){if(await this.init(),this.githubMounts.has(r)){const c=this.githubMounts.get(r);return{type:"github",owner:c.owner,repo:c.repo,branch:c.branch}}return this.mounts.has(r)?{type:"local"}:null}async getMounts(){return[...Array.from(this.mounts.keys()),...Array.from(this.githubMounts.keys())]}async flushFile(r){await this.init();const c=this.normalizePath(r),i=await this.pathLocks.acquire(c);try{const{alias:o,relativeParts:t}=this.parsePath(r);if(!o)throw new Error("Cannot flush: Path is not part of a mounted workspace.");const e=this.mounts.get(o);if(!e)throw new Error("Mount point not found.");if(this.tombstones.has(c)){try{const g=t.slice(0,-1),w=t[t.length-1];let d=e;for(const v of g)d=await d.getDirectoryHandle(v);await d.removeEntry(w,{recursive:!0}),this.tombstones.delete(c),await this.saveManifest()}catch(g){console.warn("Failed to delete local file (maybe already gone?)",g)}return}let a;try{const g=await this.overlayRoot.getDirectoryHandle(o);a=await this.traverse(g,t,!1)}catch{throw new Error("Nothing to flush: File has no pending changes in overlay.")}const l=await(await a.getFile()).arrayBuffer();let n=e;for(let g=0;g<t.length-1;g++)n=await n.getDirectoryHandle(t[g],{create:!0});const h=t[t.length-1],u=await(await n.getFileHandle(h,{create:!0})).createWritable();await u.write(l),await u.close(),await this.removeOverlayFile(o,t),$("write",r)}finally{i()}}async flushMount(r){if(await this.init(),!this.mounts.has(r))throw new Error("Unknown mount alias");try{const o=await this.overlayRoot.getDirectoryHandle(r),t=await this.getFilesRecursively(o);for(const e of t){const a=`/${r}/${e}`;await this.flushFile(a)}}catch{}const c=`/${r}/`,i=Array.from(this.tombstones).filter(o=>o.startsWith(c));for(const o of i)await this.flushFile(o)}async discardChange(r){await this.init();const{alias:c,relativeParts:i}=this.parsePath(r),o=this.normalizePath(r);c&&(this.tombstones.has(o)&&(this.tombstones.delete(o),await this.saveManifest()),await this.removeOverlayFile(c,i),$("write",r))}async diff(r){await this.init();const{alias:c,relativeParts:i}=this.parsePath(r),o=this.normalizePath(r);if(!c)throw new Error("Diff is only supported for mounted files.");const t=this.tombstones.has(o);let e="",a="",s=!1,l=!1;try{const n=this.mounts.get(c);e=await(await(await this.traverse(n,i,!1)).getFile()).text(),s=!0}catch{}if(t)l=!1;else try{const n=await this.overlayRoot.getDirectoryHandle(c);a=await(await(await this.traverse(n,i,!1)).getFile()).text(),l=!0}catch{if(s)return""}return!s&&!l?"":!s&&l?this.generateUnifiedDiff(null,a,r,"new file"):s&&!l?t?this.generateUnifiedDiff(e,null,r,"deleted"):"":this.generateUnifiedDiff(e,a,r)}async addTags(r,c){await this.init();const i=this.normalizePath(r),o=await this.pathLocks.acquire(i);try{this.attributes[i]||(this.attributes[i]={tags:[]});const t=new Set(this.attributes[i].tags);c.forEach(e=>t.add(e)),this.attributes[i].tags=Array.from(t),await this.saveManifest(),$("tags_change",r)}finally{o()}}async removeTags(r,c){await this.init();const i=this.normalizePath(r),o=await this.pathLocks.acquire(i);try{this.attributes[i]&&(this.attributes[i].tags=this.attributes[i].tags.filter(t=>!c.includes(t)),await this.saveManifest(),$("tags_change",r))}finally{o()}}async searchByTags(r){await this.init();const c=[];for(const[i,o]of Object.entries(this.attributes))r.every(t=>o.tags.includes(t))&&c.push(i);return c}async getTags(r){var o;await this.init();const c=this.normalizePath(r),i=await this.pathLocks.acquire(c);try{return((o=this.attributes[c])==null?void 0:o.tags)||[]}finally{i()}}async list(r="/",c=!1){await this.init(),console.log("Listing: "+r);let i=[];const{alias:o,relativeParts:t}=this.parsePath(r);if(r==="/"||r===""){for(const e of this.mounts.keys())i.push({name:e,kind:"directory",path:`/${e}`,size:0,status:"original"});for(const e of this.githubMounts.keys())i.push({name:e,kind:"directory",path:`/${e}`,size:0,status:"original"});for await(const[e,a]of this.root.entries())(!c||!e.startsWith("."))&&i.push(await this.meta(a,`/${e}`,"original"));return this.filterTombstones(i)}if(o){const e=new Map,a=t.join("/"),s=await this.getScopedMatcher(o,a),l=n=>{const h=a?`${a}/${n}`:n;return s.ignores(h)};try{if(this.mounts.has(o)){console.log("loc mnt "+o);let n=this.mounts.get(o);for(const h of t)n=await n.getDirectoryHandle(h);for await(const[h,f]of n.entries())l(h)||e.set(h,await this.meta(f,`${r}/${h}`,"original"))}else if(this.githubMounts.has(o)){console.log("gith mnt "+o);const n=this.githubMounts.get(o);await this.ensureGithubTree(o);const h=a?a+"/":"";for(const[f,u]of n.tree.entries())if(f.startsWith(h)){const g=f.slice(h.length);g&&!g.includes("/")&&(l(u.name)||e.set(u.name,{...u,path:`${r}/${u.name}`}))}}else console.log("mount is not found "+o)}catch(n){return console.log(n),[]}try{let n=await this.overlayRoot.getDirectoryHandle(o);for(const h of t)n=await n.getDirectoryHandle(h);for await(const[h,f]of n.entries())if(!l(h)){const u=e.has(h)?"modified":"new";e.set(h,await this.meta(f,`${r}/${h}`,u))}}catch{}i=Array.from(e.values())}else try{const e=await this.traverse(this.root,this.parsePath(r).parts,!1);for await(const[a,s]of e.entries())i.push(await this.meta(s,`${r}/${a}`,"original"))}catch{return[]}return this.filterTombstones(i)}async getMetadata(r){await this.init();const c=this.normalizePath(r);if(this.tombstones.has(c))throw new Error("ENOENT");try{const{handle:i,source:o}=await this.resolveForRead(r),{alias:t}=this.parsePath(r),e=o==="local"?"original":t?"modified":"original";return await this.meta(i,c,e)}catch{throw new Error("ENOENT")}}async listRecursive(r="/"){const c=await this.listLimiter.run(()=>this.list(r));return(await Promise.all(c.map(async o=>o.kind==="directory"?[o,...await this.listRecursive(o.path)]:[o]))).flat()}async write(r,c){const i=this.normalizePath(r),o=await this.pathLocks.acquire(i);try{const e=await(await this.resolveForWrite(r)).createSyncAccessHandle();try{const a=typeof c=="string"?this.textEncoder.encode(c):c;if(e.truncate(0),e.write(a,{at:0}),e.flush(),r.endsWith(".gitignore")){const{alias:s}=this.parsePath(r);s&&this.invalidateIgnoreCache(s)}$("write",r)}finally{e.close(),this.lineIndexCache.delete(i)}}finally{o()}}async applyPatch(r,c){const i=I.patch_fromText(c);if(i.length===0)throw Error("No valid patches found in content");const o=this.normalizePath(r),t=await this.pathLocks.acquire(o);try{const a=await(await this.resolveForWrite(r)).createSyncAccessHandle();try{const s=a.getSize();let l=new Uint8Array(s);a.read(l,{at:0});let n=new TextDecoder().decode(l);l=null;let[h,f]=I.patch_apply(i,n);n=null;const u=f.filter(w=>w===!0).length;if(f.every(w=>w===!0)){let w=this.textEncoder.encode(h);h=null,a.write(w,{at:0}),a.truncate(w.length),w=null,a.flush(),this.lineIndexCache.delete(o),$("write",r)}else{const w=f.map((d,v)=>d?null:v+1).filter(d=>d!==null);throw new Error(`Patch failed: ${f.length-u} of ${f.length} hunks failed to apply. Failed hunks: #${w.join(", #")}. No changes were written to the file. Please re-read the file to ensure your patch context is up-to-date.`)}}finally{a.close()}}finally{t()}}async append(r,c){const i=this.normalizePath(r),o=await this.pathLocks.acquire(i);try{const e=await(await this.resolveForWrite(r)).createSyncAccessHandle();try{const a=typeof c=="string"?this.textEncoder.encode(c+`
`):c,s=e.getSize();e.write(a,{at:s}),e.flush(),$("write",r)}finally{e.close(),this.lineIndexCache.delete(i)}}finally{o()}}async replaceRange(r,c,i,o,t,e){await this.init();const a=(await this.readWindow(r,c,c)).trim(),s=(await this.readWindow(r,i,i)).trim();if(t&&a!==t.trim())throw new Error(`Safety Mismatch at start line ${c}.
Expected: "${t.trim()}"
Actual:   "${a.trim()}"`);if(e&&s!==e.trim())throw new Error(`Safety Mismatch at end line ${i}.
Expected: "${e.trim()}"
Actual:   "${s.trim()}"`);const l=this.normalizePath(r),n=await this.pathLocks.acquire(l);try{const h=await this.resolveForWrite(r),{startOffset:f,endOffset:u,totalSize:g}=await this.getLineBoundaries(l,h,"opfs",c,i),w=crypto.randomUUID(),d=await this.root.getDirectoryHandle(".system",{create:!0}),v=await d.getFileHandle(`swap_${w}.tmp`,{create:!0}),m=await h.createSyncAccessHandle(),y=await v.createSyncAccessHandle();try{f>0&&await this.streamCopy(m,y,0,f,0);const _=b=>{let M;typeof b=="string"?M=this.textEncoder.encode(b):M=b,y.write(M,{at:y.getSize()})};if(typeof o=="string")_(o);else for(let b of o)_(b);const k=g-u;k>0&&await this.streamCopy(m,y,u,k,y.getSize()),m.truncate(y.getSize()),await this.streamCopy(y,m,0,y.getSize(),0),$("write",r)}finally{m.close(),y.close(),await d.removeEntry(`swap_${w}.tmp`)}}finally{n()}}async readWindow(r,c,i){const o=this.normalizePath(r),t=await this.pathLocks.acquire(o);try{const{handle:e,source:a}=await this.resolveForRead(r),{startOffset:s,endOffset:l}=await this.getLineBoundaries(o,e,a,c,i);return s>=l?"":await(await e.getFile()).slice(s,l).text()}finally{t()}}async grep(r,c={}){await this.init();const o=(await this.listRecursive("/")).filter(e=>{var a,s,l;return!(e.kind!=="file"||(a=c.paths)!=null&&a.length&&!c.paths.includes(e.path)||(s=c.include_paths)!=null&&s.length&&!c.include_paths.some(n=>e.path.includes(n))||(l=c.exclude_paths)!=null&&l.length&&c.exclude_paths.some(n=>e.path.includes(n)))});return(await Promise.all(o.map(async e=>this.grepLimiter.run(async()=>[...await this.grepFile(e.path,r)])))).flat()}async grepFile(r,c){const i=this.normalizePath(r),o=await this.pathLocks.acquire(i);try{const{handle:t}=await this.resolveForRead(r),a=(await t.getFile()).stream().getReader(),s=[];let l=1,n="";for(;;){const{done:h,value:f}=await a.read();if(h)break;const u=this.textDecoder.decode(f,{stream:!0}),g=(n+u).split(/\r?\n/);n=g.pop()||"";for(const w of g)w.includes(c)&&s.push({line:l,content:w.trim()}),l++}return n.includes(c)&&(l++,s.push({line:l,content:n.trim()})),s}finally{o()}}async delete(r){await this.init();const c=this.normalizePath(r),i=await this.pathLocks.acquire(c);try{await this._delete(c)}finally{i()}}async _delete(r){for(const t of Object.keys(this.attributes))(t===r||t.startsWith(r+"/"))&&delete this.attributes[t];const{alias:c,relativeParts:i,parts:o}=this.parsePath(r);if(c){this.tombstones.add(r),await this.saveManifest();try{let t=await this.overlayRoot.getDirectoryHandle(c);const e=i.pop();for(const a of i)t=await t.getDirectoryHandle(a);await t.removeEntry(e,{recursive:!0})}catch{}}else{const t=o.slice(0,-1),e=o[o.length-1];let a=this.root;for(const s of t)a=await a.getDirectoryHandle(s);await a.removeEntry(e,{recursive:!0})}if(this.attributes[r]&&delete this.attributes[r],r.endsWith("/.gitignore")){const{alias:t}=this.parsePath(r);t&&this.invalidateIgnoreCache(t)}await this.saveManifest(),$("delete",r)}async countLines(r){const c=this.normalizePath(r),i=await this.pathLocks.acquire(c);try{const{handle:o,source:t}=await this.resolveForRead(r);let e=0;if(t==="opfs"){const a=await o.createSyncAccessHandle();try{const s=a.getSize();if(s===0)return 0;const l=new Uint8Array(64*1024);let n=0;for(;n<s;){const h=a.read(l,{at:n});for(let f=0;f<h;f++)l[f]===10&&e++;n+=h}}finally{a.close()}}else{const a=await o.getFile();if(a.size===0)return 0;const s=a.stream().getReader();for(;;){const{done:l,value:n}=await s.read();if(l)break;for(let h=0;h<n.length;h++)n[h]===10&&e++}}return e+1}finally{i()}}async readFile(r){const{handle:c}=await this.resolveForRead(r);return c.getFile()}async readBytes(r,c,i){const{handle:o,source:t}=await this.resolveForRead(r);if(t==="opfs"){const e=await o.createSyncAccessHandle();try{const a=new Uint8Array(i),s=e.read(a,{at:c});return a.subarray(0,s)}finally{e.close()}}else{const s=await(await o.getFile()).slice(c,c+i).arrayBuffer();return new Uint8Array(s)}}async writeBytes(r,c,i){const o=this.normalizePath(r),t=await this.pathLocks.acquire(o);try{const a=await(await this.resolveForWrite(r)).createSyncAccessHandle();try{const s=a.write(c,{at:i});return a.flush(),s}finally{a.close()}}finally{t()}}async truncate(r,c){const i=this.normalizePath(r),o=await this.pathLocks.acquire(i);try{const e=await(await this.resolveForWrite(r)).createSyncAccessHandle();try{e.truncate(c),e.flush()}finally{e.close(),this.lineIndexCache.delete(i)}}finally{o()}}async streamCopy(r,c,i,o,t){const a=new Uint8Array(65536);let s=o,l=i,n=t??c.getSize();for(;s>0;){const h=r.read(a.subarray(0,Math.min(65536,s)),{at:l});if(h===0)break;c.write(a.subarray(0,h),{at:n}),l+=h,n+=h,s-=h}}async rename(r,c){const i=this.normalizePath(r),o=this.normalizePath(c),t=[i,o].sort(),e=await this.pathLocks.acquire(t[0]),a=await this.pathLocks.acquire(t[1]);try{const s=await this.resolveForWrite(r),l=await this.resolveForWrite(c),n=await s.createSyncAccessHandle(),h=await l.createSyncAccessHandle();try{const f=n.getSize();h.truncate(0),await this.streamCopy(n,h,0,f,0),h.flush()}finally{n.close(),h.close()}this.attributes[i]&&(this.attributes[o]={...this.attributes[i]}),await this._delete(r)}finally{a(),e()}}async mkdir(r){await this.init();const c=this.normalizePath(r),{alias:i,relativeParts:o,parts:t}=this.parsePath(c),e=await this.pathLocks.acquire(c);try{if(this.tombstones.has(c)&&(this.tombstones.delete(c),await this.saveManifest()),i){let s=await this.overlayRoot.getDirectoryHandle(i,{create:!0});for(const l of o)s=await s.getDirectoryHandle(l,{create:!0})}else{let a=this.root;for(const s of t)a=await a.getDirectoryHandle(s,{create:!0})}$("write",r)}finally{e()}}async storeImage(r,c){const i=`images/${crypto.randomUUID()+J(r)}`;return await this.write(i,c),i}}const p=new X;self.onmessage=async D=>{const{id:r,method:c,args:i}=D.data;try{let o;switch(c){case"mount":o=await p.mount(i.alias,i.handle);break;case"mountGithub":o=await p.mountGithub(i.alias,i.owner,i.repo,i.branch);break;case"setGithubToken":o=await p.setGithubToken(i.token);break;case"getMounts":o=await p.getMounts();break;case"getMountInfo":o=await p.getMountInfo(i.alias);break;case"unmount":o=await p.unmount(i.alias);break;case"flushFile":o=await p.flushFile(i.path);break;case"flushMount":o=await p.flushMount(i.alias);break;case"discardChange":o=await p.discardChange(i.path);break;case"diff":o=await p.diff(i.path);break;case"addTags":o=await p.addTags(i.path,i.tags);break;case"removeTags":o=await p.removeTags(i.path,i.tags);break;case"searchByTags":o=await p.searchByTags(i.tags);break;case"getTags":o=await p.getTags(i.path);break;case"getMetadata":o=await p.getMetadata(i.path);break;case"list":o=await p.list(i.path);break;case"listRecursive":o=await p.listRecursive(i.path);break;case"write":o=await p.write(i.path,i.content);break;case"applyPatch":o=await p.applyPatch(i.path,i.content);break;case"replaceRange":o=await p.replaceRange(i.path,i.startLine,i.endLine,i.newContent,i.expectedStart,i.expectedEnd);break;case"append":o=await p.append(i.path,i.content);break;case"readWindow":o=await p.readWindow(i.path,i.startLine,i.endLine);break;case"grep":o=await p.grep(i.query,i.options);break;case"grepFile":o=await p.grepFile(i.path,i.query);break;case"delete":o=await p.delete(i.path);break;case"countLines":o=await p.countLines(i.path);break;case"readFile":o=await p.readFile(i.path);break;case"readBytes":o=await p.readBytes(i.path,i.offset,i.length);break;case"writeBytes":o=await p.writeBytes(i.path,i.buffer,i.offset);break;case"truncate":o=await p.truncate(i.path,i.size);break;case"rename":o=await p.rename(i.oldPath,i.newPath);break;case"mkdir":o=await p.mkdir(i.path);break;case"storeImage":o=await p.storeImage(i.mimeType,i.data);break;default:throw new Error(`Unknown method: ${c}`)}self.postMessage({id:r,status:"success",result:o})}catch(o){self.postMessage({id:r,status:"error",error:o.message})}}})();
