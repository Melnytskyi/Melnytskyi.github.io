(function(){"use strict";var R={exports:{}},T;function B(){return T||(T=1,(function(F){var a=function(){this.Diff_Timeout=1,this.Diff_EditCost=4,this.Match_Threshold=.5,this.Match_Distance=1e3,this.Patch_DeleteThreshold=.5,this.Patch_Margin=4,this.Match_MaxBits=32},c=-1,n=1,o=0;a.Diff=function(t,e){return[t,e]},a.prototype.diff_main=function(t,e,r,i){typeof i>"u"&&(this.Diff_Timeout<=0?i=Number.MAX_VALUE:i=new Date().getTime()+this.Diff_Timeout*1e3);var l=i;if(t==null||e==null)throw new Error("Null input. (diff_main)");if(t==e)return t?[new a.Diff(o,t)]:[];typeof r>"u"&&(r=!0);var s=r,h=this.diff_commonPrefix(t,e),f=t.substring(0,h);t=t.substring(h),e=e.substring(h),h=this.diff_commonSuffix(t,e);var u=t.substring(t.length-h);t=t.substring(0,t.length-h),e=e.substring(0,e.length-h);var g=this.diff_compute_(t,e,s,l);return f&&g.unshift(new a.Diff(o,f)),u&&g.push(new a.Diff(o,u)),this.diff_cleanupMerge(g),g},a.prototype.diff_compute_=function(t,e,r,i){var l;if(!t)return[new a.Diff(n,e)];if(!e)return[new a.Diff(c,t)];var s=t.length>e.length?t:e,h=t.length>e.length?e:t,f=s.indexOf(h);if(f!=-1)return l=[new a.Diff(n,s.substring(0,f)),new a.Diff(o,h),new a.Diff(n,s.substring(f+h.length))],t.length>e.length&&(l[0][0]=l[2][0]=c),l;if(h.length==1)return[new a.Diff(c,t),new a.Diff(n,e)];var u=this.diff_halfMatch_(t,e);if(u){var g=u[0],w=u[1],d=u[2],v=u[3],m=u[4],y=this.diff_main(g,d,r,i),_=this.diff_main(w,v,r,i);return y.concat([new a.Diff(o,m)],_)}return r&&t.length>100&&e.length>100?this.diff_lineMode_(t,e,i):this.diff_bisect_(t,e,i)},a.prototype.diff_lineMode_=function(t,e,r){var i=this.diff_linesToChars_(t,e);t=i.chars1,e=i.chars2;var l=i.lineArray,s=this.diff_main(t,e,!1,r);this.diff_charsToLines_(s,l),this.diff_cleanupSemantic(s),s.push(new a.Diff(o,""));for(var h=0,f=0,u=0,g="",w="";h<s.length;){switch(s[h][0]){case n:u++,w+=s[h][1];break;case c:f++,g+=s[h][1];break;case o:if(f>=1&&u>=1){s.splice(h-f-u,f+u),h=h-f-u;for(var d=this.diff_main(g,w,!1,r),v=d.length-1;v>=0;v--)s.splice(h,0,d[v]);h=h+d.length}u=0,f=0,g="",w="";break}h++}return s.pop(),s},a.prototype.diff_bisect_=function(t,e,r){for(var i=t.length,l=e.length,s=Math.ceil((i+l)/2),h=s,f=2*s,u=new Array(f),g=new Array(f),w=0;w<f;w++)u[w]=-1,g[w]=-1;u[h+1]=0,g[h+1]=0;for(var d=i-l,v=d%2!=0,m=0,y=0,_=0,D=0,b=0;b<s&&!(new Date().getTime()>r);b++){for(var M=-b+m;M<=b-y;M+=2){var k=h+M,P;M==-b||M!=b&&u[k-1]<u[k+1]?P=u[k+1]:P=u[k-1]+1;for(var E=P-M;P<i&&E<l&&t.charAt(P)==e.charAt(E);)P++,E++;if(u[k]=P,P>i)y+=2;else if(E>l)m+=2;else if(v){var A=h+d-M;if(A>=0&&A<f&&g[A]!=-1){var H=i-g[A];if(P>=H)return this.diff_bisectSplit_(t,e,P,E,r)}}}for(var S=-b+_;S<=b-D;S+=2){var A=h+S,H;S==-b||S!=b&&g[A-1]<g[A+1]?H=g[A+1]:H=g[A-1]+1;for(var $=H-S;H<i&&$<l&&t.charAt(i-H-1)==e.charAt(l-$-1);)H++,$++;if(g[A]=H,H>i)D+=2;else if($>l)_+=2;else if(!v){var k=h+d-S;if(k>=0&&k<f&&u[k]!=-1){var P=u[k],E=h+P-k;if(H=i-H,P>=H)return this.diff_bisectSplit_(t,e,P,E,r)}}}}return[new a.Diff(c,t),new a.Diff(n,e)]},a.prototype.diff_bisectSplit_=function(t,e,r,i,l){var s=t.substring(0,r),h=e.substring(0,i),f=t.substring(r),u=e.substring(i),g=this.diff_main(s,h,!1,l),w=this.diff_main(f,u,!1,l);return g.concat(w)},a.prototype.diff_linesToChars_=function(t,e){var r=[],i={};r[0]="";function l(u){for(var g="",w=0,d=-1,v=r.length;d<u.length-1;){d=u.indexOf(`
`,w),d==-1&&(d=u.length-1);var m=u.substring(w,d+1);(i.hasOwnProperty?i.hasOwnProperty(m):i[m]!==void 0)?g+=String.fromCharCode(i[m]):(v==s&&(m=u.substring(w),d=u.length),g+=String.fromCharCode(v),i[m]=v,r[v++]=m),w=d+1}return g}var s=4e4,h=l(t);s=65535;var f=l(e);return{chars1:h,chars2:f,lineArray:r}},a.prototype.diff_charsToLines_=function(t,e){for(var r=0;r<t.length;r++){for(var i=t[r][1],l=[],s=0;s<i.length;s++)l[s]=e[i.charCodeAt(s)];t[r][1]=l.join("")}},a.prototype.diff_commonPrefix=function(t,e){if(!t||!e||t.charAt(0)!=e.charAt(0))return 0;for(var r=0,i=Math.min(t.length,e.length),l=i,s=0;r<l;)t.substring(s,l)==e.substring(s,l)?(r=l,s=r):i=l,l=Math.floor((i-r)/2+r);return l},a.prototype.diff_commonSuffix=function(t,e){if(!t||!e||t.charAt(t.length-1)!=e.charAt(e.length-1))return 0;for(var r=0,i=Math.min(t.length,e.length),l=i,s=0;r<l;)t.substring(t.length-l,t.length-s)==e.substring(e.length-l,e.length-s)?(r=l,s=r):i=l,l=Math.floor((i-r)/2+r);return l},a.prototype.diff_commonOverlap_=function(t,e){var r=t.length,i=e.length;if(r==0||i==0)return 0;r>i?t=t.substring(r-i):r<i&&(e=e.substring(0,r));var l=Math.min(r,i);if(t==e)return l;for(var s=0,h=1;;){var f=t.substring(l-h),u=e.indexOf(f);if(u==-1)return s;h+=u,(u==0||t.substring(l-h)==e.substring(0,h))&&(s=h,h++)}},a.prototype.diff_halfMatch_=function(t,e){if(this.Diff_Timeout<=0)return null;var r=t.length>e.length?t:e,i=t.length>e.length?e:t;if(r.length<4||i.length*2<r.length)return null;var l=this;function s(y,_,D){for(var b=y.substring(D,D+Math.floor(y.length/4)),M=-1,k="",P,E,A,H;(M=_.indexOf(b,M+1))!=-1;){var S=l.diff_commonPrefix(y.substring(D),_.substring(M)),$=l.diff_commonSuffix(y.substring(0,D),_.substring(0,M));k.length<$+S&&(k=_.substring(M-$,M)+_.substring(M,M+S),P=y.substring(0,D-$),E=y.substring(D+S),A=_.substring(0,M-$),H=_.substring(M+S))}return k.length*2>=y.length?[P,E,A,H,k]:null}var h=s(r,i,Math.ceil(r.length/4)),f=s(r,i,Math.ceil(r.length/2)),u;if(!h&&!f)return null;f?h?u=h[4].length>f[4].length?h:f:u=f:u=h;var g,w,d,v;t.length>e.length?(g=u[0],w=u[1],d=u[2],v=u[3]):(d=u[0],v=u[1],g=u[2],w=u[3]);var m=u[4];return[g,w,d,v,m]},a.prototype.diff_cleanupSemantic=function(t){for(var e=!1,r=[],i=0,l=null,s=0,h=0,f=0,u=0,g=0;s<t.length;)t[s][0]==o?(r[i++]=s,h=u,f=g,u=0,g=0,l=t[s][1]):(t[s][0]==n?u+=t[s][1].length:g+=t[s][1].length,l&&l.length<=Math.max(h,f)&&l.length<=Math.max(u,g)&&(t.splice(r[i-1],0,new a.Diff(c,l)),t[r[i-1]+1][0]=n,i--,i--,s=i>0?r[i-1]:-1,h=0,f=0,u=0,g=0,l=null,e=!0)),s++;for(e&&this.diff_cleanupMerge(t),this.diff_cleanupSemanticLossless(t),s=1;s<t.length;){if(t[s-1][0]==c&&t[s][0]==n){var w=t[s-1][1],d=t[s][1],v=this.diff_commonOverlap_(w,d),m=this.diff_commonOverlap_(d,w);v>=m?(v>=w.length/2||v>=d.length/2)&&(t.splice(s,0,new a.Diff(o,d.substring(0,v))),t[s-1][1]=w.substring(0,w.length-v),t[s+1][1]=d.substring(v),s++):(m>=w.length/2||m>=d.length/2)&&(t.splice(s,0,new a.Diff(o,w.substring(0,m))),t[s-1][0]=n,t[s-1][1]=d.substring(0,d.length-m),t[s+1][0]=c,t[s+1][1]=w.substring(m),s++),s++}s++}},a.prototype.diff_cleanupSemanticLossless=function(t){function e(m,y){if(!m||!y)return 6;var _=m.charAt(m.length-1),D=y.charAt(0),b=_.match(a.nonAlphaNumericRegex_),M=D.match(a.nonAlphaNumericRegex_),k=b&&_.match(a.whitespaceRegex_),P=M&&D.match(a.whitespaceRegex_),E=k&&_.match(a.linebreakRegex_),A=P&&D.match(a.linebreakRegex_),H=E&&m.match(a.blanklineEndRegex_),S=A&&y.match(a.blanklineStartRegex_);return H||S?5:E||A?4:b&&!k&&P?3:k||P?2:b||M?1:0}for(var r=1;r<t.length-1;){if(t[r-1][0]==o&&t[r+1][0]==o){var i=t[r-1][1],l=t[r][1],s=t[r+1][1],h=this.diff_commonSuffix(i,l);if(h){var f=l.substring(l.length-h);i=i.substring(0,i.length-h),l=f+l.substring(0,l.length-h),s=f+s}for(var u=i,g=l,w=s,d=e(i,l)+e(l,s);l.charAt(0)===s.charAt(0);){i+=l.charAt(0),l=l.substring(1)+s.charAt(0),s=s.substring(1);var v=e(i,l)+e(l,s);v>=d&&(d=v,u=i,g=l,w=s)}t[r-1][1]!=u&&(u?t[r-1][1]=u:(t.splice(r-1,1),r--),t[r][1]=g,w?t[r+1][1]=w:(t.splice(r+1,1),r--))}r++}},a.nonAlphaNumericRegex_=/[^a-zA-Z0-9]/,a.whitespaceRegex_=/\s/,a.linebreakRegex_=/[\r\n]/,a.blanklineEndRegex_=/\n\r?\n$/,a.blanklineStartRegex_=/^\r?\n\r?\n/,a.prototype.diff_cleanupEfficiency=function(t){for(var e=!1,r=[],i=0,l=null,s=0,h=!1,f=!1,u=!1,g=!1;s<t.length;)t[s][0]==o?(t[s][1].length<this.Diff_EditCost&&(u||g)?(r[i++]=s,h=u,f=g,l=t[s][1]):(i=0,l=null),u=g=!1):(t[s][0]==c?g=!0:u=!0,l&&(h&&f&&u&&g||l.length<this.Diff_EditCost/2&&h+f+u+g==3)&&(t.splice(r[i-1],0,new a.Diff(c,l)),t[r[i-1]+1][0]=n,i--,l=null,h&&f?(u=g=!0,i=0):(i--,s=i>0?r[i-1]:-1,u=g=!1),e=!0)),s++;e&&this.diff_cleanupMerge(t)},a.prototype.diff_cleanupMerge=function(t){t.push(new a.Diff(o,""));for(var e=0,r=0,i=0,l="",s="",h;e<t.length;)switch(t[e][0]){case n:i++,s+=t[e][1],e++;break;case c:r++,l+=t[e][1],e++;break;case o:r+i>1?(r!==0&&i!==0&&(h=this.diff_commonPrefix(s,l),h!==0&&(e-r-i>0&&t[e-r-i-1][0]==o?t[e-r-i-1][1]+=s.substring(0,h):(t.splice(0,0,new a.Diff(o,s.substring(0,h))),e++),s=s.substring(h),l=l.substring(h)),h=this.diff_commonSuffix(s,l),h!==0&&(t[e][1]=s.substring(s.length-h)+t[e][1],s=s.substring(0,s.length-h),l=l.substring(0,l.length-h))),e-=r+i,t.splice(e,r+i),l.length&&(t.splice(e,0,new a.Diff(c,l)),e++),s.length&&(t.splice(e,0,new a.Diff(n,s)),e++),e++):e!==0&&t[e-1][0]==o?(t[e-1][1]+=t[e][1],t.splice(e,1)):e++,i=0,r=0,l="",s="";break}t[t.length-1][1]===""&&t.pop();var f=!1;for(e=1;e<t.length-1;)t[e-1][0]==o&&t[e+1][0]==o&&(t[e][1].substring(t[e][1].length-t[e-1][1].length)==t[e-1][1]?(t[e][1]=t[e-1][1]+t[e][1].substring(0,t[e][1].length-t[e-1][1].length),t[e+1][1]=t[e-1][1]+t[e+1][1],t.splice(e-1,1),f=!0):t[e][1].substring(0,t[e+1][1].length)==t[e+1][1]&&(t[e-1][1]+=t[e+1][1],t[e][1]=t[e][1].substring(t[e+1][1].length)+t[e+1][1],t.splice(e+1,1),f=!0)),e++;f&&this.diff_cleanupMerge(t)},a.prototype.diff_xIndex=function(t,e){var r=0,i=0,l=0,s=0,h;for(h=0;h<t.length&&(t[h][0]!==n&&(r+=t[h][1].length),t[h][0]!==c&&(i+=t[h][1].length),!(r>e));h++)l=r,s=i;return t.length!=h&&t[h][0]===c?s:s+(e-l)},a.prototype.diff_prettyHtml=function(t){for(var e=[],r=/&/g,i=/</g,l=/>/g,s=/\n/g,h=0;h<t.length;h++){var f=t[h][0],u=t[h][1],g=u.replace(r,"&amp;").replace(i,"&lt;").replace(l,"&gt;").replace(s,"&para;<br>");switch(f){case n:e[h]='<ins style="background:#e6ffe6;">'+g+"</ins>";break;case c:e[h]='<del style="background:#ffe6e6;">'+g+"</del>";break;case o:e[h]="<span>"+g+"</span>";break}}return e.join("")},a.prototype.diff_text1=function(t){for(var e=[],r=0;r<t.length;r++)t[r][0]!==n&&(e[r]=t[r][1]);return e.join("")},a.prototype.diff_text2=function(t){for(var e=[],r=0;r<t.length;r++)t[r][0]!==c&&(e[r]=t[r][1]);return e.join("")},a.prototype.diff_levenshtein=function(t){for(var e=0,r=0,i=0,l=0;l<t.length;l++){var s=t[l][0],h=t[l][1];switch(s){case n:r+=h.length;break;case c:i+=h.length;break;case o:e+=Math.max(r,i),r=0,i=0;break}}return e+=Math.max(r,i),e},a.prototype.diff_toDelta=function(t){for(var e=[],r=0;r<t.length;r++)switch(t[r][0]){case n:e[r]="+"+encodeURI(t[r][1]);break;case c:e[r]="-"+t[r][1].length;break;case o:e[r]="="+t[r][1].length;break}return e.join("	").replace(/%20/g," ")},a.prototype.diff_fromDelta=function(t,e){for(var r=[],i=0,l=0,s=e.split(/\t/g),h=0;h<s.length;h++){var f=s[h].substring(1);switch(s[h].charAt(0)){case"+":try{r[i++]=new a.Diff(n,decodeURI(f))}catch{throw new Error("Illegal escape in diff_fromDelta: "+f)}break;case"-":case"=":var u=parseInt(f,10);if(isNaN(u)||u<0)throw new Error("Invalid number in diff_fromDelta: "+f);var g=t.substring(l,l+=u);s[h].charAt(0)=="="?r[i++]=new a.Diff(o,g):r[i++]=new a.Diff(c,g);break;default:if(s[h])throw new Error("Invalid diff operation in diff_fromDelta: "+s[h])}}if(l!=t.length)throw new Error("Delta length ("+l+") does not equal source text length ("+t.length+").");return r},a.prototype.match_main=function(t,e,r){if(t==null||e==null||r==null)throw new Error("Null input. (match_main)");return r=Math.max(0,Math.min(r,t.length)),t==e?0:t.length?t.substring(r,r+e.length)==e?r:this.match_bitap_(t,e,r):-1},a.prototype.match_bitap_=function(t,e,r){if(e.length>this.Match_MaxBits)throw new Error("Pattern too long for this browser.");var i=this.match_alphabet_(e),l=this;function s(P,E){var A=P/e.length,H=Math.abs(r-E);return l.Match_Distance?A+H/l.Match_Distance:H?1:A}var h=this.Match_Threshold,f=t.indexOf(e,r);f!=-1&&(h=Math.min(s(0,f),h),f=t.lastIndexOf(e,r+e.length),f!=-1&&(h=Math.min(s(0,f),h)));var u=1<<e.length-1;f=-1;for(var g,w,d=e.length+t.length,v,m=0;m<e.length;m++){for(g=0,w=d;g<w;)s(m,r+w)<=h?g=w:d=w,w=Math.floor((d-g)/2+g);d=w;var y=Math.max(1,r-w+1),_=Math.min(r+w,t.length)+e.length,D=Array(_+2);D[_+1]=(1<<m)-1;for(var b=_;b>=y;b--){var M=i[t.charAt(b-1)];if(m===0?D[b]=(D[b+1]<<1|1)&M:D[b]=(D[b+1]<<1|1)&M|((v[b+1]|v[b])<<1|1)|v[b+1],D[b]&u){var k=s(m,b-1);if(k<=h)if(h=k,f=b-1,f>r)y=Math.max(1,2*r-f);else break}}if(s(m+1,r)>h)break;v=D}return f},a.prototype.match_alphabet_=function(t){for(var e={},r=0;r<t.length;r++)e[t.charAt(r)]=0;for(var r=0;r<t.length;r++)e[t.charAt(r)]|=1<<t.length-r-1;return e},a.prototype.patch_addContext_=function(t,e){if(e.length!=0){if(t.start2===null)throw Error("patch not initialized");for(var r=e.substring(t.start2,t.start2+t.length1),i=0;e.indexOf(r)!=e.lastIndexOf(r)&&r.length<this.Match_MaxBits-this.Patch_Margin-this.Patch_Margin;)i+=this.Patch_Margin,r=e.substring(t.start2-i,t.start2+t.length1+i);i+=this.Patch_Margin;var l=e.substring(t.start2-i,t.start2);l&&t.diffs.unshift(new a.Diff(o,l));var s=e.substring(t.start2+t.length1,t.start2+t.length1+i);s&&t.diffs.push(new a.Diff(o,s)),t.start1-=l.length,t.start2-=l.length,t.length1+=l.length+s.length,t.length2+=l.length+s.length}},a.prototype.patch_make=function(t,e,r){var i,l;if(typeof t=="string"&&typeof e=="string"&&typeof r>"u")i=t,l=this.diff_main(i,e,!0),l.length>2&&(this.diff_cleanupSemantic(l),this.diff_cleanupEfficiency(l));else if(t&&typeof t=="object"&&typeof e>"u"&&typeof r>"u")l=t,i=this.diff_text1(l);else if(typeof t=="string"&&e&&typeof e=="object"&&typeof r>"u")i=t,l=e;else if(typeof t=="string"&&typeof e=="string"&&r&&typeof r=="object")i=t,l=r;else throw new Error("Unknown call format to patch_make.");if(l.length===0)return[];for(var s=[],h=new a.patch_obj,f=0,u=0,g=0,w=i,d=i,v=0;v<l.length;v++){var m=l[v][0],y=l[v][1];switch(!f&&m!==o&&(h.start1=u,h.start2=g),m){case n:h.diffs[f++]=l[v],h.length2+=y.length,d=d.substring(0,g)+y+d.substring(g);break;case c:h.length1+=y.length,h.diffs[f++]=l[v],d=d.substring(0,g)+d.substring(g+y.length);break;case o:y.length<=2*this.Patch_Margin&&f&&l.length!=v+1?(h.diffs[f++]=l[v],h.length1+=y.length,h.length2+=y.length):y.length>=2*this.Patch_Margin&&f&&(this.patch_addContext_(h,w),s.push(h),h=new a.patch_obj,f=0,w=d,u=g);break}m!==n&&(u+=y.length),m!==c&&(g+=y.length)}return f&&(this.patch_addContext_(h,w),s.push(h)),s},a.prototype.patch_deepCopy=function(t){for(var e=[],r=0;r<t.length;r++){var i=t[r],l=new a.patch_obj;l.diffs=[];for(var s=0;s<i.diffs.length;s++)l.diffs[s]=new a.Diff(i.diffs[s][0],i.diffs[s][1]);l.start1=i.start1,l.start2=i.start2,l.length1=i.length1,l.length2=i.length2,e[r]=l}return e},a.prototype.patch_apply=function(t,e){if(t.length==0)return[e,[]];t=this.patch_deepCopy(t);var r=this.patch_addPadding(t);e=r+e+r,this.patch_splitMax(t);for(var i=0,l=[],s=0;s<t.length;s++){var h=t[s].start2+i,f=this.diff_text1(t[s].diffs),u,g=-1;if(f.length>this.Match_MaxBits?(u=this.match_main(e,f.substring(0,this.Match_MaxBits),h),u!=-1&&(g=this.match_main(e,f.substring(f.length-this.Match_MaxBits),h+f.length-this.Match_MaxBits),(g==-1||u>=g)&&(u=-1))):u=this.match_main(e,f,h),u==-1)l[s]=!1,i-=t[s].length2-t[s].length1;else{l[s]=!0,i=u-h;var w;if(g==-1?w=e.substring(u,u+f.length):w=e.substring(u,g+this.Match_MaxBits),f==w)e=e.substring(0,u)+this.diff_text2(t[s].diffs)+e.substring(u+f.length);else{var d=this.diff_main(f,w,!1);if(f.length>this.Match_MaxBits&&this.diff_levenshtein(d)/f.length>this.Patch_DeleteThreshold)l[s]=!1;else{this.diff_cleanupSemanticLossless(d);for(var v=0,m,y=0;y<t[s].diffs.length;y++){var _=t[s].diffs[y];_[0]!==o&&(m=this.diff_xIndex(d,v)),_[0]===n?e=e.substring(0,u+m)+_[1]+e.substring(u+m):_[0]===c&&(e=e.substring(0,u+m)+e.substring(u+this.diff_xIndex(d,v+_[1].length))),_[0]!==c&&(v+=_[1].length)}}}}}return e=e.substring(r.length,e.length-r.length),[e,l]},a.prototype.patch_addPadding=function(t){for(var e=this.Patch_Margin,r="",i=1;i<=e;i++)r+=String.fromCharCode(i);for(var i=0;i<t.length;i++)t[i].start1+=e,t[i].start2+=e;var l=t[0],s=l.diffs;if(s.length==0||s[0][0]!=o)s.unshift(new a.Diff(o,r)),l.start1-=e,l.start2-=e,l.length1+=e,l.length2+=e;else if(e>s[0][1].length){var h=e-s[0][1].length;s[0][1]=r.substring(s[0][1].length)+s[0][1],l.start1-=h,l.start2-=h,l.length1+=h,l.length2+=h}if(l=t[t.length-1],s=l.diffs,s.length==0||s[s.length-1][0]!=o)s.push(new a.Diff(o,r)),l.length1+=e,l.length2+=e;else if(e>s[s.length-1][1].length){var h=e-s[s.length-1][1].length;s[s.length-1][1]+=r.substring(0,h),l.length1+=h,l.length2+=h}return r},a.prototype.patch_splitMax=function(t){for(var e=this.Match_MaxBits,r=0;r<t.length;r++)if(!(t[r].length1<=e)){var i=t[r];t.splice(r--,1);for(var l=i.start1,s=i.start2,h="";i.diffs.length!==0;){var f=new a.patch_obj,u=!0;for(f.start1=l-h.length,f.start2=s-h.length,h!==""&&(f.length1=f.length2=h.length,f.diffs.push(new a.Diff(o,h)));i.diffs.length!==0&&f.length1<e-this.Patch_Margin;){var g=i.diffs[0][0],w=i.diffs[0][1];g===n?(f.length2+=w.length,s+=w.length,f.diffs.push(i.diffs.shift()),u=!1):g===c&&f.diffs.length==1&&f.diffs[0][0]==o&&w.length>2*e?(f.length1+=w.length,l+=w.length,u=!1,f.diffs.push(new a.Diff(g,w)),i.diffs.shift()):(w=w.substring(0,e-f.length1-this.Patch_Margin),f.length1+=w.length,l+=w.length,g===o?(f.length2+=w.length,s+=w.length):u=!1,f.diffs.push(new a.Diff(g,w)),w==i.diffs[0][1]?i.diffs.shift():i.diffs[0][1]=i.diffs[0][1].substring(w.length))}h=this.diff_text2(f.diffs),h=h.substring(h.length-this.Patch_Margin);var d=this.diff_text1(i.diffs).substring(0,this.Patch_Margin);d!==""&&(f.length1+=d.length,f.length2+=d.length,f.diffs.length!==0&&f.diffs[f.diffs.length-1][0]===o?f.diffs[f.diffs.length-1][1]+=d:f.diffs.push(new a.Diff(o,d))),u||t.splice(++r,0,f)}}},a.prototype.patch_toText=function(t){for(var e=[],r=0;r<t.length;r++)e[r]=t[r];return e.join("")},a.prototype.patch_fromText=function(t){var e=[];if(!t)return e;for(var r=t.split(`
`),i=0,l=/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;i<r.length;){var s=r[i].match(l);if(!s)throw new Error("Invalid patch string: "+r[i]);var h=new a.patch_obj;for(e.push(h),h.start1=parseInt(s[1],10),s[2]===""?(h.start1--,h.length1=1):s[2]=="0"?h.length1=0:(h.start1--,h.length1=parseInt(s[2],10)),h.start2=parseInt(s[3],10),s[4]===""?(h.start2--,h.length2=1):s[4]=="0"?h.length2=0:(h.start2--,h.length2=parseInt(s[4],10)),i++;i<r.length;){var f=r[i].charAt(0);try{var u=decodeURI(r[i].substring(1))}catch{throw new Error("Illegal escape in patch_fromText: "+u)}if(f=="-")h.diffs.push(new a.Diff(c,u));else if(f=="+")h.diffs.push(new a.Diff(n,u));else if(f==" ")h.diffs.push(new a.Diff(o,u));else{if(f=="@")break;if(f!=="")throw new Error('Invalid patch mode "'+f+'" in: '+u)}i++}}return e},a.patch_obj=function(){this.diffs=[],this.start1=null,this.start2=null,this.length1=0,this.length2=0},a.patch_obj.prototype.toString=function(){var t,e;this.length1===0?t=this.start1+",0":this.length1==1?t=this.start1+1:t=this.start1+1+","+this.length1,this.length2===0?e=this.start2+",0":this.length2==1?e=this.start2+1:e=this.start2+1+","+this.length2;for(var r=["@@ -"+t+" +"+e+` @@
`],i,l=0;l<this.diffs.length;l++){switch(this.diffs[l][0]){case n:i="+";break;case c:i="-";break;case o:i=" ";break}r[l+1]=i+encodeURI(this.diffs[l][1])+`
`}return r.join("").replace(/%20/g," ")},F.exports=a,F.exports.diff_match_patch=a,F.exports.DIFF_DELETE=c,F.exports.DIFF_INSERT=n,F.exports.DIFF_EQUAL=o})(R)),R.exports}var O=B();class L{constructor(){this.rules=[]}clone(){const a=new L;return a.rules=[...this.rules],a}add(a,c=""){const n=c?c.endsWith("/")?c:`${c}/`:"";a.split(/\r?\n/).forEach(o=>{if(o=o.trim(),!o||o.startsWith("#"))return;let t=o.startsWith("!");t&&(o=o.substring(1));let e=o.startsWith("/");e&&(o=o.substring(1));let r=o.replace(/[.+?^${}()|[\]\\]/g,"\\$&").replace(/\*\*/g,"__DOUBLE_WILD__").replace(/\*/g,"[^/]*").replace(/__DOUBLE_WILD__/g,".*").replace(/\?/g,".");e?r="^"+n+r:r="^"+n+"(?:.*/)?"+r,r.endsWith("/")?r+=".*":r+="($|/.*)",this.rules.push({regex:new RegExp(r),negative:t})})}ignores(a){const c=a.startsWith("/")?a.slice(1):a;let n=!1;for(const o of this.rules)o.regex.test(c)&&(n=!o.negative);return n}}const I=new O.diff_match_patch;I.Diff_EditCost=4,I.Patch_Margin=3;class W{constructor(){this.queue=[],this.active=0,this.limit=5,this.interval=100,this.lastRequestTime=0}async acquire(){const c=Date.now()-this.lastRequestTime;c<this.interval&&await new Promise(n=>setTimeout(n,this.interval-c)),this.active>=this.limit&&await new Promise(n=>this.queue.push(n)),this.active++,this.lastRequestTime=Date.now()}release(){if(this.active--,this.queue.length>0){const a=this.queue.shift();a&&a()}}}class N{constructor(a){this.active=0,this.queue=[],this.limit=a}async acquire(){if(this.active<this.limit){this.active++;return}await new Promise(a=>this.queue.push(a)),this.active++}release(){this.active--,this.queue.length>0&&this.queue.shift()()}async run(a){await this.acquire();try{return await a()}finally{this.release()}}}class U{constructor(){this.promise=Promise.resolve()}async acquire(){let a;const c=new Promise(o=>a=o),n=this.promise;return this.promise=c,await n,a}}class q{constructor(){this.locks=new Map}async acquire(a){for(;this.locks.has(a);)await this.locks.get(a);let c;const n=new Promise(o=>c=o);return this.locks.set(a,n),()=>{this.locks.delete(a),c()}}}function z(F,a){self.postMessage({id:"event",status:"fs_change",result:{type:F,path:a}})}function C(){return new Promise((F,a)=>{const c=indexedDB.open("fs_mounts",1);c.onupgradeneeded=()=>{const n=c.result;n.objectStoreNames.contains("handles")||n.createObjectStore("handles")},c.onsuccess=()=>F(c.result),c.onerror=()=>a(c.error)})}async function j(F,a){const c=await C();return new Promise((n,o)=>{const t=c.transaction("handles","readwrite");t.objectStore("handles").put(a,F),t.oncomplete=()=>n(),t.onerror=()=>o(t.error)})}async function G(){const F=await C();return new Promise((a,c)=>{const o=F.transaction("handles","readonly").objectStore("handles"),t=o.getAllKeys(),e=new Map;t.onsuccess=()=>{const r=t.result;if(r.length===0){a(e);return}let i=0;r.forEach(l=>{const s=o.get(l);s.onsuccess=()=>{e.set(l,s.result),i++,i===r.length&&a(e)}})},t.onerror=()=>c(t.error)})}async function K(F){const a=await C();return new Promise((c,n)=>{const o=a.transaction("handles","readwrite");o.objectStore("handles").delete(F),o.oncomplete=()=>c(),o.onerror=()=>n(o.error)})}class J{constructor(){this.rateLimiter=new W,this.grepLimiter=new N(20),this.listLimiter=new N(50),this.root=null,this.overlayRoot=null,this.mounts=new Map,this.githubMounts=new Map,this.githubToken=null,this.ignoreCache=new Map,this.lineIndexCache=new Map,this.INDEX_CHUNK_SIZE=64*1024,this.attributes={},this.tombstones=new Set,this.textEncoder=new TextEncoder,this.textDecoder=new TextDecoder,this.initialized=!1,this.manifestLock=new U,this.pathLocks=new q}setGithubToken(a){this.githubToken=a}async fetchGithub(a){await this.rateLimiter.acquire();try{const c={Accept:"application/vnd.github.v3+json"};this.githubToken&&(c.Authorization=`Bearer ${this.githubToken}`);const n=await fetch(a,{headers:c});if(n.status===403||n.status===429){const o=n.headers.get("x-ratelimit-reset"),t=n.headers.get("retry-after");let e=1e3;if(t)e=parseInt(t)*1e3;else if(o){const r=parseInt(o)*1e3;e=Math.max(1e3,r-Date.now())}if(e>1e4)throw new Error(`GitHub Rate Limit Exceeded. Try again in ${Math.round(e/1e3)}s.`);return await new Promise(r=>setTimeout(r,e)),fetch(a,{headers:c})}if(!n.ok)throw new Error(`GitHub API Error: ${n.statusText}`);return n}finally{this.rateLimiter.release()}}async ensureGithubTree(a){const c=this.githubMounts.get(a);if(c||console.log("mount is not init"+a),c.treeFetched||console.log("nount is fetched"+a),!c||c.treeFetched)return;console.log("mount proceed init "+a);const n=`https://api.github.com/repos/${c.owner}/${c.repo}/git/trees/${c.branch}?recursive=1`,t=await(await this.fetchGithub(n)).json();if(t.truncated&&console.warn("GitHub tree truncated"),c.tree.clear(),t.tree){for(const e of t.tree)if(e.type==="blob"||e.type==="tree"){const r=`/${a}/${e.path}`;c.tree.set(e.path,{name:e.path.split("/").pop(),kind:e.type==="tree"?"directory":"file",size:e.size||0,path:r,status:"original"})}}c.treeFetched=!0}async fetchGithubContent(a,c){const n=`https://api.github.com/repos/${a.owner}/${a.repo}/contents/${c}?ref=${a.branch}`,t=await(await this.fetchGithub(n)).json();if(Array.isArray(t))throw new Error("Path is a directory");if(!t.content)return new Blob([""]);const e=atob(t.content.replace(/\n/g,"")),r=new Uint8Array(e.length);for(let i=0;i<e.length;i++)r[i]=e.charCodeAt(i);return new Blob([r])}async saveGithubMounts(){const a=await this.manifestLock.acquire();try{const o=await(await(await this.root.getDirectoryHandle(".system",{create:!0})).getFileHandle("github_mounts.json",{create:!0})).createWritable(),t=Array.from(this.githubMounts.entries()).map(([e,r])=>({alias:e,owner:r.owner,repo:r.repo,branch:r.branch}));await o.write(JSON.stringify(t)),await o.close()}finally{a()}}async saveManifest(){const a=await this.manifestLock.acquire();try{const c=await this.root.getDirectoryHandle(".system",{create:!0}),n=async(o,t)=>{const r=await(await c.getFileHandle(o,{create:!0})).createWritable();await r.write(JSON.stringify(t)),await r.close()};n("attributes.json",this.attributes),n("tombstones.json",Array.from(this.tombstones))}finally{a()}}async getLineBoundaries(a,c,n,o,t){const e=await c.getFile(),{lastModified:r,size:i}=e;let l=this.lineIndexCache.get(a);(!l||l.mtime!==r||l.size!==i)&&(l=await this.rebuildLineIndex(c,n,r,i),this.lineIndexCache.set(a,l));const s=o<=1?0:l.offsets[o-1]??i;let h=i;return t!==void 0&&(h=l.offsets[t]??i),{startOffset:s,endOffset:h,totalSize:i}}async rebuildLineIndex(a,c,n,o){const t=[0],e=new Uint8Array(this.INDEX_CHUNK_SIZE);let r=null,i=null;c==="opfs"?r=await a.createSyncAccessHandle():i=await a.getFile();try{let l=0;for(;l<o;){let s=0;if(r)s=r.read(e,{at:l});else{const h=i.slice(l,l+this.INDEX_CHUNK_SIZE),f=new Uint8Array(await h.arrayBuffer());s=f.length,e.set(f)}for(let h=0;h<s;h++)e[h]===10&&t.push(l+h+1);l+=s}return{mtime:n,size:o,offsets:new Uint32Array(t)}}finally{r==null||r.close()}}normalizePath(a){return a.startsWith("/")?a:`/${a}`}parsePath(a){const n=(a.startsWith("/")?a.slice(1):a).split("/").filter(e=>e.length>0),o=n[0],t=this.mounts.has(o)||this.githubMounts.has(o);return{parts:n,alias:t?o:null,relativeParts:t?n.slice(1):n}}async resolveForRead(a){await this.init();const c=this.normalizePath(a);if(this.tombstones.has(c))throw new Error(`Entry not found (tombstoned): ${a}`);const{alias:n,relativeParts:o,parts:t}=this.parsePath(c);if(n){const e=await this.overlayRoot.getDirectoryHandle(n,{create:!0});try{return{handle:await this.traverse(e,o,!1),source:"opfs"}}catch{}if(this.mounts.has(n)){const r=this.mounts.get(n);return{handle:await this.traverse(r,o,!1),source:"local"}}if(this.githubMounts.has(n))try{return{handle:await this.traverse(e,o,!1),source:"opfs"}}catch{const i=await this.traverse(e,o,!0),l=this.githubMounts.get(n),s=await this.fetchGithubContent(l,o.join("/")),h=await i.createSyncAccessHandle();try{const f=new Uint8Array(await s.arrayBuffer());h.write(f,{at:0}),h.flush()}finally{h.close()}return{handle:i,source:"opfs"}}}return{handle:await this.traverse(this.root,t,!1),source:"opfs"}}async resolveForWrite(a){await this.init();const c=this.normalizePath(a),{alias:n,relativeParts:o,parts:t}=this.parsePath(a);if(this.tombstones.has(c)&&(this.tombstones.delete(c),await this.saveManifest()),!n)return await this.traverse(this.root,t,!0);const e=await this.overlayRoot.getDirectoryHandle(n,{create:!0});try{return await this.traverse(e,o,!1)}catch{}const r=await this.traverse(e,o,!0);try{if(this.mounts.has(n)){const i=this.mounts.get(n),h=(await(await this.traverse(i,o,!1)).getFile()).stream().getReader(),f=await r.createSyncAccessHandle();try{let u=0;for(;;){const{done:g,value:w}=await h.read();if(g)break;f.write(w,{at:u}),u+=w.length}f.flush()}finally{f.close()}}else if(this.githubMounts.has(n)){const i=this.githubMounts.get(n);try{const l=await this.fetchGithubContent(i,o.join("/")),s=await r.createSyncAccessHandle();try{const h=new Uint8Array(await l.arrayBuffer());s.write(h,{at:0}),s.flush()}finally{s.close()}}catch{}}}catch{}return r}async present(a,c){if(c.length===0)return!0;let n=a;const o=c[c.length-1];try{for(let t=0;t<c.length-1;t++)n=await n.getDirectoryHandle(c[t],{create:!0});await n.getFileHandle(o)}catch{try{await n.getDirectoryHandle(o)}catch{return!1}}return!0}async traverse(a,c,n){if(c.length===0)return a;let o=a;for(let e=0;e<c.length-1;e++)o=await o.getDirectoryHandle(c[e],{create:n});const t=c[c.length-1];if(n)return await o.getFileHandle(t,{create:n});try{return await o.getFileHandle(t)}catch{try{return await o.getDirectoryHandle(t)}catch{throw new Error(`Path not found: ${c.join("/")}`)}}}filterTombstones(a){return a.filter(c=>!this.tombstones.has(this.normalizePath(c.path)))}async meta(a,c,n){let o=0,t=0;if(a.kind==="file"){const e=await a.getFile();o=e.size,t=e.lastModified}return{name:a.name,kind:a.kind,path:c,size:o,lastModified:t,status:n}}async removeOverlayFile(a,c){try{const n=await this.overlayRoot.getDirectoryHandle(a),o=[];let t=n;const e=c[c.length-1],r=c.slice(0,-1);for(const i of r)o.push({name:i,handle:t}),t=await t.getDirectoryHandle(i);if(await t.removeEntry(e,{recursive:!0}),await this.isDirectoryEmpty(t)){let i=r[r.length-1];for(let l=o.length-1;l>=0;l--){const s=o[l];if(await s.handle.removeEntry(i,{recursive:!0}),l>0&&await this.isDirectoryEmpty(s.handle)){i=s.name;continue}else break}}}catch{}}async isDirectoryEmpty(a){for await(const c of a.keys())return!1;return!0}async getFilesRecursively(a,c=""){const n=[];for await(const[o,t]of a.entries()){const e=c?`${c}/${o}`:o;t.kind==="file"?n.push(e):n.push(...await this.getFilesRecursively(t,e))}return n}generateUnifiedDiff(a,c,n,o){const t=a?a.split(/\r?\n/):[],e=c?c.split(/\r?\n/):[],r=n.startsWith("/")?n.slice(1):n;let i=[];if(o==="new file")return i.push("--- /dev/null"),i.push(`+++ ${r}`),i.push(`@@ -0,0 +1,${e.length} @@`),e.forEach(f=>i.push(`+${f}`)),i.join(`
`);if(o==="deleted")return i.push(`--- ${r}`),i.push("+++ /dev/null"),i.push(`@@ -1,${t.length} +0,0 @@`),t.forEach(f=>i.push(`-${f}`)),i.join(`
`);const l=I.diff_main(a||"",c||"");I.diff_cleanupSemantic(l);const s=I.patch_make(a||"",l),h=I.patch_toText(s);return h.trim()?`--- a/${r}
+++ b/${r}
${decodeURIComponent(h)}`:""}async readGitIgnore(a,c){try{const n=this.mounts.get(a);if(n){let o=n;if(c)for(const r of c.split("/"))o=await o.getDirectoryHandle(r);return await(await(await o.getFileHandle(".gitignore")).getFile()).text()}}catch{}return null}async getScopedMatcher(a,c){const n=`${a}:${c}`;if(this.ignoreCache.has(n))return this.ignoreCache.get(n);if(c===""||c==="."){const l=new L;l.add(".git/");const s=await this.readGitIgnore(a,"");return s&&l.add(s,""),this.ignoreCache.set(n,l),l}const o=c.split("/"),t=o.slice(0,-1).join("/");o[o.length-1];const r=(await this.getScopedMatcher(a,t)).clone(),i=await this.readGitIgnore(a,c);return i&&r.add(i,c),this.ignoreCache.set(n,r),r}invalidateIgnoreCache(a){for(const c of this.ignoreCache.keys())c.startsWith(`${a}:`)&&this.ignoreCache.delete(c)}async init(){if(this.initialized)return;const a=await this.manifestLock.acquire();try{if(this.initialized)return;this.root=await navigator.storage.getDirectory(),this.overlayRoot=await this.root.getDirectoryHandle(".overlay",{create:!0});const c=await this.root.getDirectoryHandle(".system",{create:!0});try{const o=await(await c.getFileHandle("attributes.json")).getFile();this.attributes=JSON.parse(await o.text())}catch{this.attributes={}}try{const o=await(await c.getFileHandle("tombstones.json")).getFile(),t=JSON.parse(await o.text());this.tombstones=new Set(t)}catch{this.tombstones=new Set}try{const o=await(await c.getFileHandle("github_mounts.json")).getFile();JSON.parse(await o.text()).forEach(e=>{this.githubMounts.set(e.alias,{owner:e.owner,repo:e.repo,branch:e.branch,tree:new Map,treeFetched:!1})})}catch{}try{const n=await G();for(const[o,t]of n)this.mounts.set(o,t)}catch(n){console.error("Failed to load local mounts",n)}this.initialized=!0}finally{a()}}async mount(a,c){if(await this.init(),this.mounts.has(a)||this.githubMounts.has(a))throw new Error(`Alias ${a} already in use`);return await j(a,c),this.mounts.set(a,c),!0}async mountGithub(a,c,n,o){if(await this.init(),this.mounts.has(a)||this.githubMounts.has(a))throw new Error(`Alias ${a} already in use`);return this.githubMounts.set(a,{owner:c,repo:n,branch:o,tree:new Map,treeFetched:!1}),await this.saveGithubMounts(),!0}async unmount(a){const c=`/${a}/`;for(const n of Object.keys(this.attributes))n.startsWith(c)&&delete this.attributes[n];return this.mounts.has(a)&&(this.mounts.delete(a),await K(a)),this.githubMounts.has(a)&&(this.githubMounts.delete(a),await this.saveGithubMounts()),this.delete(".overlay/"+a),this.tombstones=new Set(Array.from(this.tombstones).filter(n=>!n.startsWith(a))),this.invalidateIgnoreCache(a),await this.saveManifest(),!0}async getMountInfo(a){if(await this.init(),this.githubMounts.has(a)){const c=this.githubMounts.get(a);return{type:"github",owner:c.owner,repo:c.repo,branch:c.branch}}return this.mounts.has(a)?{type:"local"}:null}async getMounts(){return[...Array.from(this.mounts.keys()),...Array.from(this.githubMounts.keys())]}async flushFile(a){await this.init();const c=this.normalizePath(a),n=await this.pathLocks.acquire(c);try{const{alias:o,relativeParts:t}=this.parsePath(a);if(!o)throw new Error("Cannot flush: Path is not part of a mounted workspace.");const e=this.mounts.get(o);if(!e)throw new Error("Mount point not found.");if(this.tombstones.has(c)){try{const g=t.slice(0,-1),w=t[t.length-1];let d=e;for(const v of g)d=await d.getDirectoryHandle(v);await d.removeEntry(w,{recursive:!0}),this.tombstones.delete(c),await this.saveManifest()}catch(g){console.warn("Failed to delete local file (maybe already gone?)",g)}return}let r;try{const g=await this.overlayRoot.getDirectoryHandle(o);r=await this.traverse(g,t,!1)}catch{throw new Error("Nothing to flush: File has no pending changes in overlay.")}const l=await(await r.getFile()).arrayBuffer();let s=e;for(let g=0;g<t.length-1;g++)s=await s.getDirectoryHandle(t[g],{create:!0});const h=t[t.length-1],u=await(await s.getFileHandle(h,{create:!0})).createWritable();await u.write(l),await u.close(),await this.removeOverlayFile(o,t),z("write",a)}finally{n()}}async flushMount(a){if(await this.init(),!this.mounts.has(a))throw new Error("Unknown mount alias");try{const o=await this.overlayRoot.getDirectoryHandle(a),t=await this.getFilesRecursively(o);for(const e of t){const r=`/${a}/${e}`;await this.flushFile(r)}}catch{}const c=`/${a}/`,n=Array.from(this.tombstones).filter(o=>o.startsWith(c));for(const o of n)await this.flushFile(o)}async discardChange(a){await this.init();const{alias:c,relativeParts:n}=this.parsePath(a),o=this.normalizePath(a);c&&(this.tombstones.has(o)&&(this.tombstones.delete(o),await this.saveManifest()),await this.removeOverlayFile(c,n),z("write",a))}async diff(a){await this.init();const{alias:c,relativeParts:n}=this.parsePath(a),o=this.normalizePath(a);if(!c)throw new Error("Diff is only supported for mounted files.");const t=this.tombstones.has(o);let e="",r="",i=!1,l=!1;try{const s=this.mounts.get(c);e=await(await(await this.traverse(s,n,!1)).getFile()).text(),i=!0}catch{}if(t)l=!1;else try{const s=await this.overlayRoot.getDirectoryHandle(c);r=await(await(await this.traverse(s,n,!1)).getFile()).text(),l=!0}catch{if(i)return""}return!i&&!l?"":!i&&l?this.generateUnifiedDiff(null,r,a,"new file"):i&&!l?t?this.generateUnifiedDiff(e,null,a,"deleted"):"":this.generateUnifiedDiff(e,r,a)}async addTags(a,c){await this.init();const n=this.normalizePath(a),o=await this.pathLocks.acquire(n);try{this.attributes[n]||(this.attributes[n]={tags:[]});const t=new Set(this.attributes[n].tags);c.forEach(e=>t.add(e)),this.attributes[n].tags=Array.from(t),await this.saveManifest(),z("tags_change",a)}finally{o()}}async removeTags(a,c){await this.init();const n=this.normalizePath(a),o=await this.pathLocks.acquire(n);try{this.attributes[n]&&(this.attributes[n].tags=this.attributes[n].tags.filter(t=>!c.includes(t)),await this.saveManifest(),z("tags_change",a))}finally{o()}}async searchByTags(a){await this.init();const c=[];for(const[n,o]of Object.entries(this.attributes))a.every(t=>o.tags.includes(t))&&c.push(n);return c}async getTags(a){var o;await this.init();const c=this.normalizePath(a),n=await this.pathLocks.acquire(c);try{return((o=this.attributes[c])==null?void 0:o.tags)||[]}finally{n()}}async list(a="/",c=!1){await this.init(),console.log("Listing: "+a);let n=[];const{alias:o,relativeParts:t}=this.parsePath(a);if(a==="/"||a===""){for(const e of this.mounts.keys())n.push({name:e,kind:"directory",path:`/${e}`,size:0,status:"original"});for(const e of this.githubMounts.keys())n.push({name:e,kind:"directory",path:`/${e}`,size:0,status:"original"});for await(const[e,r]of this.root.entries())(!c||!e.startsWith("."))&&n.push(await this.meta(r,`/${e}`,"original"));return this.filterTombstones(n)}if(o){const e=new Map,r=t.join("/"),i=await this.getScopedMatcher(o,r),l=s=>{const h=r?`${r}/${s}`:s;return i.ignores(h)};try{if(this.mounts.has(o)){console.log("loc mnt "+o);let s=this.mounts.get(o);for(const h of t)s=await s.getDirectoryHandle(h);for await(const[h,f]of s.entries())l(h)||e.set(h,await this.meta(f,`${a}/${h}`,"original"))}else if(this.githubMounts.has(o)){console.log("gith mnt "+o);const s=this.githubMounts.get(o);await this.ensureGithubTree(o);const h=r?r+"/":"";for(const[f,u]of s.tree.entries())if(f.startsWith(h)){const g=f.slice(h.length);g&&!g.includes("/")&&(l(u.name)||e.set(u.name,{...u,path:`${a}/${u.name}`}))}}else console.log("mount is not found "+o)}catch(s){return console.log(s),[]}try{let s=await this.overlayRoot.getDirectoryHandle(o);for(const h of t)s=await s.getDirectoryHandle(h);for await(const[h,f]of s.entries())if(!l(h)){const u=e.has(h)?"modified":"new";e.set(h,await this.meta(f,`${a}/${h}`,u))}}catch{}n=Array.from(e.values())}else try{const e=await this.traverse(this.root,this.parsePath(a).parts,!1);for await(const[r,i]of e.entries())n.push(await this.meta(i,`${a}/${r}`,"original"))}catch{return[]}return this.filterTombstones(n)}async getMetadata(a){await this.init();const c=this.normalizePath(a);if(this.tombstones.has(c))throw new Error("ENOENT");try{const{handle:n,source:o}=await this.resolveForRead(a),{alias:t}=this.parsePath(a),e=o==="local"?"original":t?"modified":"original";return await this.meta(n,c,e)}catch{throw new Error("ENOENT")}}async listRecursive(a="/"){const c=await this.listLimiter.run(()=>this.list(a));return(await Promise.all(c.map(async o=>o.kind==="directory"?[o,...await this.listRecursive(o.path)]:[o]))).flat()}async write(a,c){const n=this.normalizePath(a),o=await this.pathLocks.acquire(n);try{const e=await(await this.resolveForWrite(a)).createSyncAccessHandle();try{const r=typeof c=="string"?this.textEncoder.encode(c):c;if(e.truncate(0),e.write(r,{at:0}),e.flush(),a.endsWith(".gitignore")){const{alias:i}=this.parsePath(a);i&&this.invalidateIgnoreCache(i)}z("write",a)}finally{e.close(),this.lineIndexCache.delete(n)}}finally{o()}}async applyPatch(a,c){const n=I.patch_fromText(c);if(n.length===0)throw Error("No valid patches found in content");const o=this.normalizePath(a),t=await this.pathLocks.acquire(o);try{const r=await(await this.resolveForWrite(a)).createSyncAccessHandle();try{const i=r.getSize();let l=new Uint8Array(i);r.read(l,{at:0});let s=new TextDecoder().decode(l);l=null;let[h,f]=I.patch_apply(n,s);s=null;const u=f.filter(w=>w===!0).length;if(u>0){let w=this.textEncoder.encode(h);if(h=null,r.write(w,{at:0}),r.truncate(w.length),w=null,r.flush(),this.lineIndexCache.delete(o),z("write",a),u<f.length){const d=f.map((v,m)=>v?null:m+1).filter(v=>v!==null);throw new Error(`Patch partially applied: ${u} of ${f.length} hunks succeeded. Failed hunks: #${d.join(", #")}. The file content may have changed since you last read it. Please re-read the file to ensure you have the latest content before patching.`)}}else throw Error("Patch failed to apply to any hunk")}finally{r.close()}}finally{t()}}async append(a,c){const n=this.normalizePath(a),o=await this.pathLocks.acquire(n);try{const e=await(await this.resolveForWrite(a)).createSyncAccessHandle();try{const r=typeof c=="string"?this.textEncoder.encode(c+`
`):c,i=e.getSize();e.write(r,{at:i}),e.flush(),z("write",a)}finally{e.close(),this.lineIndexCache.delete(n)}}finally{o()}}async replaceRange(a,c,n,o,t,e){await this.init();const r=(await this.readWindow(a,c,c)).trim(),i=(await this.readWindow(a,n,n)).trim();if(t&&r!==t.trim())throw new Error(`Safety Mismatch at start line ${c}.
Expected: "${t.trim()}"
Actual:   "${r.trim()}"`);if(e&&i!==e.trim())throw new Error(`Safety Mismatch at end line ${n}.
Expected: "${e.trim()}"
Actual:   "${i.trim()}"`);const l=this.normalizePath(a),s=await this.pathLocks.acquire(l);try{const h=await this.resolveForWrite(a),{startOffset:f,endOffset:u,totalSize:g}=await this.getLineBoundaries(l,h,"opfs",c,n),w=crypto.randomUUID(),d=await this.root.getDirectoryHandle(".system",{create:!0}),v=await d.getFileHandle(`swap_${w}.tmp`,{create:!0}),m=await h.createSyncAccessHandle(),y=await v.createSyncAccessHandle();try{f>0&&await this.streamCopy(m,y,0,f,0);const _=b=>{let M;typeof b=="string"?M=this.textEncoder.encode(b):M=b,y.write(M,{at:y.getSize()})};if(typeof o=="string")_(o);else for(let b of o)_(b);const D=g-u;D>0&&await this.streamCopy(m,y,u,D,y.getSize()),m.truncate(y.getSize()),await this.streamCopy(y,m,0,y.getSize(),0),z("write",a)}finally{m.close(),y.close(),await d.removeEntry(`swap_${w}.tmp`)}}finally{s()}}async readWindow(a,c,n){const o=this.normalizePath(a),t=await this.pathLocks.acquire(o);try{const{handle:e,source:r}=await this.resolveForRead(a),{startOffset:i,endOffset:l}=await this.getLineBoundaries(o,e,r,c,n);return i>=l?"":await(await e.getFile()).slice(i,l).text()}finally{t()}}async grep(a,c={}){await this.init();const o=(await this.listRecursive("/")).filter(e=>{var r,i,l;return!(e.kind!=="file"||(r=c.paths)!=null&&r.length&&!c.paths.includes(e.path)||(i=c.include_paths)!=null&&i.length&&!c.include_paths.some(s=>e.path.includes(s))||(l=c.exclude_paths)!=null&&l.length&&c.exclude_paths.some(s=>e.path.includes(s)))});return(await Promise.all(o.map(async e=>this.grepLimiter.run(async()=>[...await this.grepFile(e.path,a)])))).flat()}async grepFile(a,c){const n=this.normalizePath(a),o=await this.pathLocks.acquire(n);try{const{handle:t}=await this.resolveForRead(a),r=(await t.getFile()).stream().getReader(),i=[];let l=1,s="";for(;;){const{done:h,value:f}=await r.read();if(h)break;const u=this.textDecoder.decode(f,{stream:!0}),g=(s+u).split(/\r?\n/);s=g.pop()||"";for(const w of g)w.includes(c)&&i.push({line:l,content:w.trim()}),l++}return s.includes(c)&&(l++,i.push({line:l,content:s.trim()})),i}finally{o()}}async delete(a){await this.init();const c=this.normalizePath(a),n=await this.pathLocks.acquire(c);try{await this._delete(c)}finally{n()}}async _delete(a){for(const t of Object.keys(this.attributes))(t===a||t.startsWith(a+"/"))&&delete this.attributes[t];const{alias:c,relativeParts:n,parts:o}=this.parsePath(a);if(c){this.tombstones.add(a),await this.saveManifest();try{let t=await this.overlayRoot.getDirectoryHandle(c);const e=n.pop();for(const r of n)t=await t.getDirectoryHandle(r);await t.removeEntry(e,{recursive:!0})}catch{}}else{const t=o.slice(0,-1),e=o[o.length-1];let r=this.root;for(const i of t)r=await r.getDirectoryHandle(i);await r.removeEntry(e,{recursive:!0})}if(this.attributes[a]&&delete this.attributes[a],a.endsWith("/.gitignore")){const{alias:t}=this.parsePath(a);t&&this.invalidateIgnoreCache(t)}await this.saveManifest(),z("delete",a)}async countLines(a){const c=this.normalizePath(a),n=await this.pathLocks.acquire(c);try{const{handle:o,source:t}=await this.resolveForRead(a);let e=0;if(t==="opfs"){const r=await o.createSyncAccessHandle();try{const i=r.getSize();if(i===0)return 0;const l=new Uint8Array(64*1024);let s=0;for(;s<i;){const h=r.read(l,{at:s});for(let f=0;f<h;f++)l[f]===10&&e++;s+=h}}finally{r.close()}}else{const r=await o.getFile();if(r.size===0)return 0;const i=r.stream().getReader();for(;;){const{done:l,value:s}=await i.read();if(l)break;for(let h=0;h<s.length;h++)s[h]===10&&e++}}return e+1}finally{n()}}async readFile(a){const{handle:c}=await this.resolveForRead(a);return c.getFile()}async readBytes(a,c,n){const{handle:o,source:t}=await this.resolveForRead(a);if(t==="opfs"){const e=await o.createSyncAccessHandle();try{const r=new Uint8Array(n),i=e.read(r,{at:c});return r.subarray(0,i)}finally{e.close()}}else{const i=await(await o.getFile()).slice(c,c+n).arrayBuffer();return new Uint8Array(i)}}async writeBytes(a,c,n){const o=this.normalizePath(a),t=await this.pathLocks.acquire(o);try{const r=await(await this.resolveForWrite(a)).createSyncAccessHandle();try{const i=r.write(c,{at:n});return r.flush(),i}finally{r.close()}}finally{t()}}async truncate(a,c){const n=this.normalizePath(a),o=await this.pathLocks.acquire(n);try{const e=await(await this.resolveForWrite(a)).createSyncAccessHandle();try{e.truncate(c),e.flush()}finally{e.close(),this.lineIndexCache.delete(n)}}finally{o()}}async streamCopy(a,c,n,o,t){const r=new Uint8Array(65536);let i=o,l=n,s=t??c.getSize();for(;i>0;){const h=a.read(r.subarray(0,Math.min(65536,i)),{at:l});if(h===0)break;c.write(r.subarray(0,h),{at:s}),l+=h,s+=h,i-=h}}async rename(a,c){const n=this.normalizePath(a),o=this.normalizePath(c),t=[n,o].sort(),e=await this.pathLocks.acquire(t[0]),r=await this.pathLocks.acquire(t[1]);try{const i=await this.resolveForWrite(a),l=await this.resolveForWrite(c),s=await i.createSyncAccessHandle(),h=await l.createSyncAccessHandle();try{const f=s.getSize();h.truncate(0),await this.streamCopy(s,h,0,f,0),h.flush()}finally{s.close(),h.close()}this.attributes[n]&&(this.attributes[o]={...this.attributes[n]}),await this._delete(a)}finally{r(),e()}}async mkdir(a){await this.init();const c=this.normalizePath(a),{alias:n,relativeParts:o,parts:t}=this.parsePath(c),e=await this.pathLocks.acquire(c);try{if(this.tombstones.has(c)&&(this.tombstones.delete(c),await this.saveManifest()),n){let i=await this.overlayRoot.getDirectoryHandle(n,{create:!0});for(const l of o)i=await i.getDirectoryHandle(l,{create:!0})}else{let r=this.root;for(const i of t)r=await r.getDirectoryHandle(i,{create:!0})}z("write",a)}finally{e()}}}const p=new J;self.onmessage=async F=>{const{id:a,method:c,args:n}=F.data;try{let o;switch(c){case"mount":o=await p.mount(n.alias,n.handle);break;case"mountGithub":o=await p.mountGithub(n.alias,n.owner,n.repo,n.branch);break;case"setGithubToken":o=await p.setGithubToken(n.token);break;case"getMounts":o=await p.getMounts();break;case"getMountInfo":o=await p.getMountInfo(n.alias);break;case"unmount":o=await p.unmount(n.alias);break;case"flushFile":o=await p.flushFile(n.path);break;case"flushMount":o=await p.flushMount(n.alias);break;case"discardChange":o=await p.discardChange(n.path);break;case"diff":o=await p.diff(n.path);break;case"addTags":o=await p.addTags(n.path,n.tags);break;case"removeTags":o=await p.removeTags(n.path,n.tags);break;case"searchByTags":o=await p.searchByTags(n.tags);break;case"getTags":o=await p.getTags(n.path);break;case"getMetadata":o=await p.getMetadata(n.path);break;case"list":o=await p.list(n.path);break;case"listRecursive":o=await p.listRecursive(n.path);break;case"write":o=await p.write(n.path,n.content);break;case"applyPatch":o=await p.applyPatch(n.path,n.content);break;case"replaceRange":o=await p.replaceRange(n.path,n.startLine,n.endLine,n.newContent,n.expectedStart,n.expectedEnd);break;case"append":o=await p.append(n.path,n.content);break;case"readWindow":o=await p.readWindow(n.path,n.startLine,n.endLine);break;case"grep":o=await p.grep(n.query,n.options);break;case"grepFile":o=await p.grepFile(n.path,n.query);break;case"delete":o=await p.delete(n.path);break;case"countLines":o=await p.countLines(n.path);break;case"readFile":o=await p.readFile(n.path);break;case"readBytes":o=await p.readBytes(n.path,n.offset,n.length);break;case"writeBytes":o=await p.writeBytes(n.path,n.buffer,n.offset);break;case"truncate":o=await p.truncate(n.path,n.size);break;case"rename":o=await p.rename(n.oldPath,n.newPath);break;case"mkdir":o=await p.mkdir(n.path);break;default:throw new Error(`Unknown method: ${c}`)}self.postMessage({id:a,status:"success",result:o})}catch(o){self.postMessage({id:a,status:"error",error:o.message})}}})();
