(function(){"use strict";var C={exports:{}},N;function U(){return N||(N=1,(function(M){var r=function(){this.Diff_Timeout=1,this.Diff_EditCost=4,this.Match_Threshold=.5,this.Match_Distance=1e3,this.Patch_DeleteThreshold=.5,this.Patch_Margin=4,this.Match_MaxBits=32},h=-1,i=1,o=0;r.Diff=function(e,t){return[e,t]},r.prototype.diff_main=function(e,t,a,s){typeof s>"u"&&(this.Diff_Timeout<=0?s=Number.MAX_VALUE:s=new Date().getTime()+this.Diff_Timeout*1e3);var l=s;if(e==null||t==null)throw new Error("Null input. (diff_main)");if(e==t)return e?[new r.Diff(o,e)]:[];typeof a>"u"&&(a=!0);var n=a,c=this.diff_commonPrefix(e,t),f=e.substring(0,c);e=e.substring(c),t=t.substring(c),c=this.diff_commonSuffix(e,t);var u=e.substring(e.length-c);e=e.substring(0,e.length-c),t=t.substring(0,t.length-c);var g=this.diff_compute_(e,t,n,l);return f&&g.unshift(new r.Diff(o,f)),u&&g.push(new r.Diff(o,u)),this.diff_cleanupMerge(g),g},r.prototype.diff_compute_=function(e,t,a,s){var l;if(!e)return[new r.Diff(i,t)];if(!t)return[new r.Diff(h,e)];var n=e.length>t.length?e:t,c=e.length>t.length?t:e,f=n.indexOf(c);if(f!=-1)return l=[new r.Diff(i,n.substring(0,f)),new r.Diff(o,c),new r.Diff(i,n.substring(f+c.length))],e.length>t.length&&(l[0][0]=l[2][0]=h),l;if(c.length==1)return[new r.Diff(h,e),new r.Diff(i,t)];var u=this.diff_halfMatch_(e,t);if(u){var g=u[0],w=u[1],d=u[2],v=u[3],y=u[4],m=this.diff_main(g,d,a,s),b=this.diff_main(w,v,a,s);return m.concat([new r.Diff(o,y)],b)}return a&&e.length>100&&t.length>100?this.diff_lineMode_(e,t,s):this.diff_bisect_(e,t,s)},r.prototype.diff_lineMode_=function(e,t,a){var s=this.diff_linesToChars_(e,t);e=s.chars1,t=s.chars2;var l=s.lineArray,n=this.diff_main(e,t,!1,a);this.diff_charsToLines_(n,l),this.diff_cleanupSemantic(n),n.push(new r.Diff(o,""));for(var c=0,f=0,u=0,g="",w="";c<n.length;){switch(n[c][0]){case i:u++,w+=n[c][1];break;case h:f++,g+=n[c][1];break;case o:if(f>=1&&u>=1){n.splice(c-f-u,f+u),c=c-f-u;for(var d=this.diff_main(g,w,!1,a),v=d.length-1;v>=0;v--)n.splice(c,0,d[v]);c=c+d.length}u=0,f=0,g="",w="";break}c++}return n.pop(),n},r.prototype.diff_bisect_=function(e,t,a){for(var s=e.length,l=t.length,n=Math.ceil((s+l)/2),c=n,f=2*n,u=new Array(f),g=new Array(f),w=0;w<f;w++)u[w]=-1,g[w]=-1;u[c+1]=0,g[c+1]=0;for(var d=s-l,v=d%2!=0,y=0,m=0,b=0,E=0,_=0;_<n&&!(new Date().getTime()>a);_++){for(var k=-_+y;k<=_-m;k+=2){var F=c+k,H;k==-_||k!=_&&u[F-1]<u[F+1]?H=u[F+1]:H=u[F-1]+1;for(var S=H-k;H<s&&S<l&&e.charAt(H)==t.charAt(S);)H++,S++;if(u[F]=H,H>s)m+=2;else if(S>l)y+=2;else if(v){var A=c+d-k;if(A>=0&&A<f&&g[A]!=-1){var P=s-g[A];if(H>=P)return this.diff_bisectSplit_(e,t,H,S,a)}}}for(var T=-_+b;T<=_-E;T+=2){var A=c+T,P;T==-_||T!=_&&g[A-1]<g[A+1]?P=g[A+1]:P=g[A-1]+1;for(var I=P-T;P<s&&I<l&&e.charAt(s-P-1)==t.charAt(l-I-1);)P++,I++;if(g[A]=P,P>s)E+=2;else if(I>l)b+=2;else if(!v){var F=c+d-T;if(F>=0&&F<f&&u[F]!=-1){var H=u[F],S=c+H-F;if(P=s-P,H>=P)return this.diff_bisectSplit_(e,t,H,S,a)}}}}return[new r.Diff(h,e),new r.Diff(i,t)]},r.prototype.diff_bisectSplit_=function(e,t,a,s,l){var n=e.substring(0,a),c=t.substring(0,s),f=e.substring(a),u=t.substring(s),g=this.diff_main(n,c,!1,l),w=this.diff_main(f,u,!1,l);return g.concat(w)},r.prototype.diff_linesToChars_=function(e,t){var a=[],s={};a[0]="";function l(u){for(var g="",w=0,d=-1,v=a.length;d<u.length-1;){d=u.indexOf(`
`,w),d==-1&&(d=u.length-1);var y=u.substring(w,d+1);(s.hasOwnProperty?s.hasOwnProperty(y):s[y]!==void 0)?g+=String.fromCharCode(s[y]):(v==n&&(y=u.substring(w),d=u.length),g+=String.fromCharCode(v),s[y]=v,a[v++]=y),w=d+1}return g}var n=4e4,c=l(e);n=65535;var f=l(t);return{chars1:c,chars2:f,lineArray:a}},r.prototype.diff_charsToLines_=function(e,t){for(var a=0;a<e.length;a++){for(var s=e[a][1],l=[],n=0;n<s.length;n++)l[n]=t[s.charCodeAt(n)];e[a][1]=l.join("")}},r.prototype.diff_commonPrefix=function(e,t){if(!e||!t||e.charAt(0)!=t.charAt(0))return 0;for(var a=0,s=Math.min(e.length,t.length),l=s,n=0;a<l;)e.substring(n,l)==t.substring(n,l)?(a=l,n=a):s=l,l=Math.floor((s-a)/2+a);return l},r.prototype.diff_commonSuffix=function(e,t){if(!e||!t||e.charAt(e.length-1)!=t.charAt(t.length-1))return 0;for(var a=0,s=Math.min(e.length,t.length),l=s,n=0;a<l;)e.substring(e.length-l,e.length-n)==t.substring(t.length-l,t.length-n)?(a=l,n=a):s=l,l=Math.floor((s-a)/2+a);return l},r.prototype.diff_commonOverlap_=function(e,t){var a=e.length,s=t.length;if(a==0||s==0)return 0;a>s?e=e.substring(a-s):a<s&&(t=t.substring(0,a));var l=Math.min(a,s);if(e==t)return l;for(var n=0,c=1;;){var f=e.substring(l-c),u=t.indexOf(f);if(u==-1)return n;c+=u,(u==0||e.substring(l-c)==t.substring(0,c))&&(n=c,c++)}},r.prototype.diff_halfMatch_=function(e,t){if(this.Diff_Timeout<=0)return null;var a=e.length>t.length?e:t,s=e.length>t.length?t:e;if(a.length<4||s.length*2<a.length)return null;var l=this;function n(m,b,E){for(var _=m.substring(E,E+Math.floor(m.length/4)),k=-1,F="",H,S,A,P;(k=b.indexOf(_,k+1))!=-1;){var T=l.diff_commonPrefix(m.substring(E),b.substring(k)),I=l.diff_commonSuffix(m.substring(0,E),b.substring(0,k));F.length<I+T&&(F=b.substring(k-I,k)+b.substring(k,k+T),H=m.substring(0,E-I),S=m.substring(E+T),A=b.substring(0,k-I),P=b.substring(k+T))}return F.length*2>=m.length?[H,S,A,P,F]:null}var c=n(a,s,Math.ceil(a.length/4)),f=n(a,s,Math.ceil(a.length/2)),u;if(!c&&!f)return null;f?c?u=c[4].length>f[4].length?c:f:u=f:u=c;var g,w,d,v;e.length>t.length?(g=u[0],w=u[1],d=u[2],v=u[3]):(d=u[0],v=u[1],g=u[2],w=u[3]);var y=u[4];return[g,w,d,v,y]},r.prototype.diff_cleanupSemantic=function(e){for(var t=!1,a=[],s=0,l=null,n=0,c=0,f=0,u=0,g=0;n<e.length;)e[n][0]==o?(a[s++]=n,c=u,f=g,u=0,g=0,l=e[n][1]):(e[n][0]==i?u+=e[n][1].length:g+=e[n][1].length,l&&l.length<=Math.max(c,f)&&l.length<=Math.max(u,g)&&(e.splice(a[s-1],0,new r.Diff(h,l)),e[a[s-1]+1][0]=i,s--,s--,n=s>0?a[s-1]:-1,c=0,f=0,u=0,g=0,l=null,t=!0)),n++;for(t&&this.diff_cleanupMerge(e),this.diff_cleanupSemanticLossless(e),n=1;n<e.length;){if(e[n-1][0]==h&&e[n][0]==i){var w=e[n-1][1],d=e[n][1],v=this.diff_commonOverlap_(w,d),y=this.diff_commonOverlap_(d,w);v>=y?(v>=w.length/2||v>=d.length/2)&&(e.splice(n,0,new r.Diff(o,d.substring(0,v))),e[n-1][1]=w.substring(0,w.length-v),e[n+1][1]=d.substring(v),n++):(y>=w.length/2||y>=d.length/2)&&(e.splice(n,0,new r.Diff(o,w.substring(0,y))),e[n-1][0]=i,e[n-1][1]=d.substring(0,d.length-y),e[n+1][0]=h,e[n+1][1]=w.substring(y),n++),n++}n++}},r.prototype.diff_cleanupSemanticLossless=function(e){function t(y,m){if(!y||!m)return 6;var b=y.charAt(y.length-1),E=m.charAt(0),_=b.match(r.nonAlphaNumericRegex_),k=E.match(r.nonAlphaNumericRegex_),F=_&&b.match(r.whitespaceRegex_),H=k&&E.match(r.whitespaceRegex_),S=F&&b.match(r.linebreakRegex_),A=H&&E.match(r.linebreakRegex_),P=S&&y.match(r.blanklineEndRegex_),T=A&&m.match(r.blanklineStartRegex_);return P||T?5:S||A?4:_&&!F&&H?3:F||H?2:_||k?1:0}for(var a=1;a<e.length-1;){if(e[a-1][0]==o&&e[a+1][0]==o){var s=e[a-1][1],l=e[a][1],n=e[a+1][1],c=this.diff_commonSuffix(s,l);if(c){var f=l.substring(l.length-c);s=s.substring(0,s.length-c),l=f+l.substring(0,l.length-c),n=f+n}for(var u=s,g=l,w=n,d=t(s,l)+t(l,n);l.charAt(0)===n.charAt(0);){s+=l.charAt(0),l=l.substring(1)+n.charAt(0),n=n.substring(1);var v=t(s,l)+t(l,n);v>=d&&(d=v,u=s,g=l,w=n)}e[a-1][1]!=u&&(u?e[a-1][1]=u:(e.splice(a-1,1),a--),e[a][1]=g,w?e[a+1][1]=w:(e.splice(a+1,1),a--))}a++}},r.nonAlphaNumericRegex_=/[^a-zA-Z0-9]/,r.whitespaceRegex_=/\s/,r.linebreakRegex_=/[\r\n]/,r.blanklineEndRegex_=/\n\r?\n$/,r.blanklineStartRegex_=/^\r?\n\r?\n/,r.prototype.diff_cleanupEfficiency=function(e){for(var t=!1,a=[],s=0,l=null,n=0,c=!1,f=!1,u=!1,g=!1;n<e.length;)e[n][0]==o?(e[n][1].length<this.Diff_EditCost&&(u||g)?(a[s++]=n,c=u,f=g,l=e[n][1]):(s=0,l=null),u=g=!1):(e[n][0]==h?g=!0:u=!0,l&&(c&&f&&u&&g||l.length<this.Diff_EditCost/2&&c+f+u+g==3)&&(e.splice(a[s-1],0,new r.Diff(h,l)),e[a[s-1]+1][0]=i,s--,l=null,c&&f?(u=g=!0,s=0):(s--,n=s>0?a[s-1]:-1,u=g=!1),t=!0)),n++;t&&this.diff_cleanupMerge(e)},r.prototype.diff_cleanupMerge=function(e){e.push(new r.Diff(o,""));for(var t=0,a=0,s=0,l="",n="",c;t<e.length;)switch(e[t][0]){case i:s++,n+=e[t][1],t++;break;case h:a++,l+=e[t][1],t++;break;case o:a+s>1?(a!==0&&s!==0&&(c=this.diff_commonPrefix(n,l),c!==0&&(t-a-s>0&&e[t-a-s-1][0]==o?e[t-a-s-1][1]+=n.substring(0,c):(e.splice(0,0,new r.Diff(o,n.substring(0,c))),t++),n=n.substring(c),l=l.substring(c)),c=this.diff_commonSuffix(n,l),c!==0&&(e[t][1]=n.substring(n.length-c)+e[t][1],n=n.substring(0,n.length-c),l=l.substring(0,l.length-c))),t-=a+s,e.splice(t,a+s),l.length&&(e.splice(t,0,new r.Diff(h,l)),t++),n.length&&(e.splice(t,0,new r.Diff(i,n)),t++),t++):t!==0&&e[t-1][0]==o?(e[t-1][1]+=e[t][1],e.splice(t,1)):t++,s=0,a=0,l="",n="";break}e[e.length-1][1]===""&&e.pop();var f=!1;for(t=1;t<e.length-1;)e[t-1][0]==o&&e[t+1][0]==o&&(e[t][1].substring(e[t][1].length-e[t-1][1].length)==e[t-1][1]?(e[t][1]=e[t-1][1]+e[t][1].substring(0,e[t][1].length-e[t-1][1].length),e[t+1][1]=e[t-1][1]+e[t+1][1],e.splice(t-1,1),f=!0):e[t][1].substring(0,e[t+1][1].length)==e[t+1][1]&&(e[t-1][1]+=e[t+1][1],e[t][1]=e[t][1].substring(e[t+1][1].length)+e[t+1][1],e.splice(t+1,1),f=!0)),t++;f&&this.diff_cleanupMerge(e)},r.prototype.diff_xIndex=function(e,t){var a=0,s=0,l=0,n=0,c;for(c=0;c<e.length&&(e[c][0]!==i&&(a+=e[c][1].length),e[c][0]!==h&&(s+=e[c][1].length),!(a>t));c++)l=a,n=s;return e.length!=c&&e[c][0]===h?n:n+(t-l)},r.prototype.diff_prettyHtml=function(e){for(var t=[],a=/&/g,s=/</g,l=/>/g,n=/\n/g,c=0;c<e.length;c++){var f=e[c][0],u=e[c][1],g=u.replace(a,"&amp;").replace(s,"&lt;").replace(l,"&gt;").replace(n,"&para;<br>");switch(f){case i:t[c]='<ins style="background:#e6ffe6;">'+g+"</ins>";break;case h:t[c]='<del style="background:#ffe6e6;">'+g+"</del>";break;case o:t[c]="<span>"+g+"</span>";break}}return t.join("")},r.prototype.diff_text1=function(e){for(var t=[],a=0;a<e.length;a++)e[a][0]!==i&&(t[a]=e[a][1]);return t.join("")},r.prototype.diff_text2=function(e){for(var t=[],a=0;a<e.length;a++)e[a][0]!==h&&(t[a]=e[a][1]);return t.join("")},r.prototype.diff_levenshtein=function(e){for(var t=0,a=0,s=0,l=0;l<e.length;l++){var n=e[l][0],c=e[l][1];switch(n){case i:a+=c.length;break;case h:s+=c.length;break;case o:t+=Math.max(a,s),a=0,s=0;break}}return t+=Math.max(a,s),t},r.prototype.diff_toDelta=function(e){for(var t=[],a=0;a<e.length;a++)switch(e[a][0]){case i:t[a]="+"+encodeURI(e[a][1]);break;case h:t[a]="-"+e[a][1].length;break;case o:t[a]="="+e[a][1].length;break}return t.join("	").replace(/%20/g," ")},r.prototype.diff_fromDelta=function(e,t){for(var a=[],s=0,l=0,n=t.split(/\t/g),c=0;c<n.length;c++){var f=n[c].substring(1);switch(n[c].charAt(0)){case"+":try{a[s++]=new r.Diff(i,decodeURI(f))}catch{throw new Error("Illegal escape in diff_fromDelta: "+f)}break;case"-":case"=":var u=parseInt(f,10);if(isNaN(u)||u<0)throw new Error("Invalid number in diff_fromDelta: "+f);var g=e.substring(l,l+=u);n[c].charAt(0)=="="?a[s++]=new r.Diff(o,g):a[s++]=new r.Diff(h,g);break;default:if(n[c])throw new Error("Invalid diff operation in diff_fromDelta: "+n[c])}}if(l!=e.length)throw new Error("Delta length ("+l+") does not equal source text length ("+e.length+").");return a},r.prototype.match_main=function(e,t,a){if(e==null||t==null||a==null)throw new Error("Null input. (match_main)");return a=Math.max(0,Math.min(a,e.length)),e==t?0:e.length?e.substring(a,a+t.length)==t?a:this.match_bitap_(e,t,a):-1},r.prototype.match_bitap_=function(e,t,a){if(t.length>this.Match_MaxBits)throw new Error("Pattern too long for this browser.");var s=this.match_alphabet_(t),l=this;function n(H,S){var A=H/t.length,P=Math.abs(a-S);return l.Match_Distance?A+P/l.Match_Distance:P?1:A}var c=this.Match_Threshold,f=e.indexOf(t,a);f!=-1&&(c=Math.min(n(0,f),c),f=e.lastIndexOf(t,a+t.length),f!=-1&&(c=Math.min(n(0,f),c)));var u=1<<t.length-1;f=-1;for(var g,w,d=t.length+e.length,v,y=0;y<t.length;y++){for(g=0,w=d;g<w;)n(y,a+w)<=c?g=w:d=w,w=Math.floor((d-g)/2+g);d=w;var m=Math.max(1,a-w+1),b=Math.min(a+w,e.length)+t.length,E=Array(b+2);E[b+1]=(1<<y)-1;for(var _=b;_>=m;_--){var k=s[e.charAt(_-1)];if(y===0?E[_]=(E[_+1]<<1|1)&k:E[_]=(E[_+1]<<1|1)&k|((v[_+1]|v[_])<<1|1)|v[_+1],E[_]&u){var F=n(y,_-1);if(F<=c)if(c=F,f=_-1,f>a)m=Math.max(1,2*a-f);else break}}if(n(y+1,a)>c)break;v=E}return f},r.prototype.match_alphabet_=function(e){for(var t={},a=0;a<e.length;a++)t[e.charAt(a)]=0;for(var a=0;a<e.length;a++)t[e.charAt(a)]|=1<<e.length-a-1;return t},r.prototype.patch_addContext_=function(e,t){if(t.length!=0){if(e.start2===null)throw Error("patch not initialized");for(var a=t.substring(e.start2,e.start2+e.length1),s=0;t.indexOf(a)!=t.lastIndexOf(a)&&a.length<this.Match_MaxBits-this.Patch_Margin-this.Patch_Margin;)s+=this.Patch_Margin,a=t.substring(e.start2-s,e.start2+e.length1+s);s+=this.Patch_Margin;var l=t.substring(e.start2-s,e.start2);l&&e.diffs.unshift(new r.Diff(o,l));var n=t.substring(e.start2+e.length1,e.start2+e.length1+s);n&&e.diffs.push(new r.Diff(o,n)),e.start1-=l.length,e.start2-=l.length,e.length1+=l.length+n.length,e.length2+=l.length+n.length}},r.prototype.patch_make=function(e,t,a){var s,l;if(typeof e=="string"&&typeof t=="string"&&typeof a>"u")s=e,l=this.diff_main(s,t,!0),l.length>2&&(this.diff_cleanupSemantic(l),this.diff_cleanupEfficiency(l));else if(e&&typeof e=="object"&&typeof t>"u"&&typeof a>"u")l=e,s=this.diff_text1(l);else if(typeof e=="string"&&t&&typeof t=="object"&&typeof a>"u")s=e,l=t;else if(typeof e=="string"&&typeof t=="string"&&a&&typeof a=="object")s=e,l=a;else throw new Error("Unknown call format to patch_make.");if(l.length===0)return[];for(var n=[],c=new r.patch_obj,f=0,u=0,g=0,w=s,d=s,v=0;v<l.length;v++){var y=l[v][0],m=l[v][1];switch(!f&&y!==o&&(c.start1=u,c.start2=g),y){case i:c.diffs[f++]=l[v],c.length2+=m.length,d=d.substring(0,g)+m+d.substring(g);break;case h:c.length1+=m.length,c.diffs[f++]=l[v],d=d.substring(0,g)+d.substring(g+m.length);break;case o:m.length<=2*this.Patch_Margin&&f&&l.length!=v+1?(c.diffs[f++]=l[v],c.length1+=m.length,c.length2+=m.length):m.length>=2*this.Patch_Margin&&f&&(this.patch_addContext_(c,w),n.push(c),c=new r.patch_obj,f=0,w=d,u=g);break}y!==i&&(u+=m.length),y!==h&&(g+=m.length)}return f&&(this.patch_addContext_(c,w),n.push(c)),n},r.prototype.patch_deepCopy=function(e){for(var t=[],a=0;a<e.length;a++){var s=e[a],l=new r.patch_obj;l.diffs=[];for(var n=0;n<s.diffs.length;n++)l.diffs[n]=new r.Diff(s.diffs[n][0],s.diffs[n][1]);l.start1=s.start1,l.start2=s.start2,l.length1=s.length1,l.length2=s.length2,t[a]=l}return t},r.prototype.patch_apply=function(e,t){if(e.length==0)return[t,[]];e=this.patch_deepCopy(e);var a=this.patch_addPadding(e);t=a+t+a,this.patch_splitMax(e);for(var s=0,l=[],n=0;n<e.length;n++){var c=e[n].start2+s,f=this.diff_text1(e[n].diffs),u,g=-1;if(f.length>this.Match_MaxBits?(u=this.match_main(t,f.substring(0,this.Match_MaxBits),c),u!=-1&&(g=this.match_main(t,f.substring(f.length-this.Match_MaxBits),c+f.length-this.Match_MaxBits),(g==-1||u>=g)&&(u=-1))):u=this.match_main(t,f,c),u==-1)l[n]=!1,s-=e[n].length2-e[n].length1;else{l[n]=!0,s=u-c;var w;if(g==-1?w=t.substring(u,u+f.length):w=t.substring(u,g+this.Match_MaxBits),f==w)t=t.substring(0,u)+this.diff_text2(e[n].diffs)+t.substring(u+f.length);else{var d=this.diff_main(f,w,!1);if(f.length>this.Match_MaxBits&&this.diff_levenshtein(d)/f.length>this.Patch_DeleteThreshold)l[n]=!1;else{this.diff_cleanupSemanticLossless(d);for(var v=0,y,m=0;m<e[n].diffs.length;m++){var b=e[n].diffs[m];b[0]!==o&&(y=this.diff_xIndex(d,v)),b[0]===i?t=t.substring(0,u+y)+b[1]+t.substring(u+y):b[0]===h&&(t=t.substring(0,u+y)+t.substring(u+this.diff_xIndex(d,v+b[1].length))),b[0]!==h&&(v+=b[1].length)}}}}}return t=t.substring(a.length,t.length-a.length),[t,l]},r.prototype.patch_addPadding=function(e){for(var t=this.Patch_Margin,a="",s=1;s<=t;s++)a+=String.fromCharCode(s);for(var s=0;s<e.length;s++)e[s].start1+=t,e[s].start2+=t;var l=e[0],n=l.diffs;if(n.length==0||n[0][0]!=o)n.unshift(new r.Diff(o,a)),l.start1-=t,l.start2-=t,l.length1+=t,l.length2+=t;else if(t>n[0][1].length){var c=t-n[0][1].length;n[0][1]=a.substring(n[0][1].length)+n[0][1],l.start1-=c,l.start2-=c,l.length1+=c,l.length2+=c}if(l=e[e.length-1],n=l.diffs,n.length==0||n[n.length-1][0]!=o)n.push(new r.Diff(o,a)),l.length1+=t,l.length2+=t;else if(t>n[n.length-1][1].length){var c=t-n[n.length-1][1].length;n[n.length-1][1]+=a.substring(0,c),l.length1+=c,l.length2+=c}return a},r.prototype.patch_splitMax=function(e){for(var t=this.Match_MaxBits,a=0;a<e.length;a++)if(!(e[a].length1<=t)){var s=e[a];e.splice(a--,1);for(var l=s.start1,n=s.start2,c="";s.diffs.length!==0;){var f=new r.patch_obj,u=!0;for(f.start1=l-c.length,f.start2=n-c.length,c!==""&&(f.length1=f.length2=c.length,f.diffs.push(new r.Diff(o,c)));s.diffs.length!==0&&f.length1<t-this.Patch_Margin;){var g=s.diffs[0][0],w=s.diffs[0][1];g===i?(f.length2+=w.length,n+=w.length,f.diffs.push(s.diffs.shift()),u=!1):g===h&&f.diffs.length==1&&f.diffs[0][0]==o&&w.length>2*t?(f.length1+=w.length,l+=w.length,u=!1,f.diffs.push(new r.Diff(g,w)),s.diffs.shift()):(w=w.substring(0,t-f.length1-this.Patch_Margin),f.length1+=w.length,l+=w.length,g===o?(f.length2+=w.length,n+=w.length):u=!1,f.diffs.push(new r.Diff(g,w)),w==s.diffs[0][1]?s.diffs.shift():s.diffs[0][1]=s.diffs[0][1].substring(w.length))}c=this.diff_text2(f.diffs),c=c.substring(c.length-this.Patch_Margin);var d=this.diff_text1(s.diffs).substring(0,this.Patch_Margin);d!==""&&(f.length1+=d.length,f.length2+=d.length,f.diffs.length!==0&&f.diffs[f.diffs.length-1][0]===o?f.diffs[f.diffs.length-1][1]+=d:f.diffs.push(new r.Diff(o,d))),u||e.splice(++a,0,f)}}},r.prototype.patch_toText=function(e){for(var t=[],a=0;a<e.length;a++)t[a]=e[a];return t.join("")},r.prototype.patch_fromText=function(e){var t=[];if(!e)return t;for(var a=e.split(`
`),s=0,l=/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;s<a.length;){var n=a[s].match(l);if(!n)throw new Error("Invalid patch string: "+a[s]);var c=new r.patch_obj;for(t.push(c),c.start1=parseInt(n[1],10),n[2]===""?(c.start1--,c.length1=1):n[2]=="0"?c.length1=0:(c.start1--,c.length1=parseInt(n[2],10)),c.start2=parseInt(n[3],10),n[4]===""?(c.start2--,c.length2=1):n[4]=="0"?c.length2=0:(c.start2--,c.length2=parseInt(n[4],10)),s++;s<a.length;){var f=a[s].charAt(0);try{var u=decodeURI(a[s].substring(1))}catch{throw new Error("Illegal escape in patch_fromText: "+u)}if(f=="-")c.diffs.push(new r.Diff(h,u));else if(f=="+")c.diffs.push(new r.Diff(i,u));else if(f==" ")c.diffs.push(new r.Diff(o,u));else{if(f=="@")break;if(f!=="")throw new Error('Invalid patch mode "'+f+'" in: '+u)}s++}}return t},r.patch_obj=function(){this.diffs=[],this.start1=null,this.start2=null,this.length1=0,this.length2=0},r.patch_obj.prototype.toString=function(){var e,t;this.length1===0?e=this.start1+",0":this.length1==1?e=this.start1+1:e=this.start1+1+","+this.length1,this.length2===0?t=this.start2+",0":this.length2==1?t=this.start2+1:t=this.start2+1+","+this.length2;for(var a=["@@ -"+e+" +"+t+` @@
`],s,l=0;l<this.diffs.length;l++){switch(this.diffs[l][0]){case i:s="+";break;case h:s="-";break;case o:s=" ";break}a[l+1]=s+encodeURI(this.diffs[l][1])+`
`}return a.join("").replace(/%20/g," ")},M.exports=r,M.exports.diff_match_patch=r,M.exports.DIFF_DELETE=h,M.exports.DIFF_INSERT=i,M.exports.DIFF_EQUAL=o})(C)),C.exports}var O=U();class L{constructor(){this.rules=[]}clone(){const r=new L;return r.rules=[...this.rules],r}add(r,h=""){const i=h?h.endsWith("/")?h:`${h}/`:"";r.split(/\r?\n/).forEach(o=>{if(o=o.trim(),!o||o.startsWith("#"))return;let e=o.startsWith("!");e&&(o=o.substring(1));let t=o.startsWith("/");t&&(o=o.substring(1));let a=o.replace(/[.+?^${}()|[\]\\]/g,"\\$&").replace(/\*\*/g,"__DOUBLE_WILD__").replace(/\*/g,"[^/]*").replace(/__DOUBLE_WILD__/g,".*").replace(/\?/g,".");t?a="^"+i+a:a="^"+i+"(?:.*/)?"+a,a.endsWith("/")?a+=".*":a+="($|/.*)",this.rules.push({regex:new RegExp(a),negative:e})})}ignores(r){const h=r.startsWith("/")?r.slice(1):r;let i=!1;for(const o of this.rules)o.regex.test(h)&&(i=!o.negative);return i}}const R=new O.diff_match_patch;R.Diff_EditCost=4,R.Patch_Margin=3;class z{constructor(){this.queue=[],this.active=0,this.limit=5,this.interval=100,this.lastRequestTime=0}async acquire(){const h=Date.now()-this.lastRequestTime;h<this.interval&&await new Promise(i=>setTimeout(i,this.interval-h)),this.active>=this.limit&&await new Promise(i=>this.queue.push(i)),this.active++,this.lastRequestTime=Date.now()}release(){if(this.active--,this.queue.length>0){const r=this.queue.shift();r&&r()}}}class B{constructor(r){this.active=0,this.queue=[],this.limit=r}async acquire(){if(this.active<this.limit){this.active++;return}await new Promise(r=>this.queue.push(r)),this.active++}release(){this.active--,this.queue.length>0&&this.queue.shift()()}async run(r){await this.acquire();try{return await r()}finally{this.release()}}}class j{constructor(){this.promise=Promise.resolve()}async acquire(){let r;const h=new Promise(o=>r=o),i=this.promise;return this.promise=h,await i,r}}class q{constructor(){this.locks=new Map}async acquire(r){for(;this.locks.has(r);)await this.locks.get(r);let h;const i=new Promise(o=>h=o);return this.locks.set(r,i),()=>{this.locks.delete(r),h()}}}function $(M,r){self.postMessage({id:"event",status:"fs_change",result:{type:M,path:r}})}function D(M){if(!M)return"/";M=M.replace(/\\/g,"/");const r=M.split("/").filter(e=>e!==""&&e!=="."),h=[];for(const e of r)e===".."?h.length>0&&h.pop():h.push(e);const i=h.join("/"),o=M.endsWith("/")&&h.length>0;return"/"+i+(o?"/":"")}function W(){return new Promise((M,r)=>{const h=indexedDB.open("fs_mounts",1);h.onupgradeneeded=()=>{const i=h.result;i.objectStoreNames.contains("handles")||i.createObjectStore("handles")},h.onsuccess=()=>M(h.result),h.onerror=()=>r(h.error)})}async function G(M,r){const h=await W();return new Promise((i,o)=>{const e=h.transaction("handles","readwrite");e.objectStore("handles").put(r,M),e.oncomplete=()=>i(),e.onerror=()=>o(e.error)})}async function K(){const M=await W();return new Promise((r,h)=>{const o=M.transaction("handles","readonly").objectStore("handles"),e=o.getAllKeys(),t=new Map;e.onsuccess=()=>{const a=e.result;if(a.length===0){r(t);return}let s=0;a.forEach(l=>{const n=o.get(l);n.onsuccess=()=>{t.set(l,n.result),s++,s===a.length&&r(t)}})},e.onerror=()=>h(e.error)})}async function J(M){const r=await W();return new Promise((h,i)=>{const o=r.transaction("handles","readwrite");o.objectStore("handles").delete(M),o.oncomplete=()=>h(),o.onerror=()=>i(o.error)})}function X(M){switch(M){case"image/jpeg":return".jpg";case"image/png":return".png";default:return".png"}}class Z{constructor(){this.rateLimiter=new z,this.grepLimiter=new B(20),this.listLimiter=new B(50),this.root=null,this.overlayRoot=null,this.mounts=new Map,this.githubMounts=new Map,this.githubToken=null,this.ignoreCache=new Map,this.lineIndexCache=new Map,this.INDEX_CHUNK_SIZE=64*1024,this.attributes={},this.tombstones=new Set,this.textEncoder=new TextEncoder,this.textDecoder=new TextDecoder,this.initialized=!1,this.manifestLock=new j,this.pathLocks=new q}setGithubToken(r){this.githubToken=r}async fetchGithub(r){await this.rateLimiter.acquire();try{const h={Accept:"application/vnd.github.v3+json"};this.githubToken&&(h.Authorization=`Bearer ${this.githubToken}`);const i=await fetch(r,{headers:h});if(i.status===403||i.status===429){const o=i.headers.get("x-ratelimit-reset"),e=i.headers.get("retry-after");let t=1e3;if(e)t=parseInt(e)*1e3;else if(o){const a=parseInt(o)*1e3;t=Math.max(1e3,a-Date.now())}if(t>1e4)throw new Error(`GitHub Rate Limit Exceeded. Try again in ${Math.round(t/1e3)}s.`);return await new Promise(a=>setTimeout(a,t)),fetch(r,{headers:h})}if(!i.ok)throw new Error(`GitHub API Error: ${i.statusText}`);return i}finally{this.rateLimiter.release()}}async ensureGithubTree(r){const h=this.githubMounts.get(r),i=`https://api.github.com/repos/${h.owner}/${h.repo}/git/trees/${h.branch}?recursive=1`,e=await(await this.fetchGithub(i)).json();if(e.truncated&&console.warn(`GitHub tree truncated in ${h.owner}/${h.repo} branch: ${h.branch}`),h.tree.clear(),e.tree){for(const t of e.tree)if(t.type==="blob"||t.type==="tree"){const a=`/${r}/${t.path}`;h.tree.set(t.path,{name:t.path.split("/").pop(),kind:t.type==="tree"?"directory":"file",size:t.size||0,path:a,status:"original"})}}h.treeFetched=!0}async fetchGithubContent(r,h){const i=`https://api.github.com/repos/${r.owner}/${r.repo}/contents/${h}?ref=${r.branch}`,e=await(await this.fetchGithub(i)).json();if(Array.isArray(e))throw new Error("Path is a directory");if(!e.content)return new Blob([""]);const t=atob(e.content.replace(/\n/g,"")),a=new Uint8Array(t.length);for(let s=0;s<t.length;s++)a[s]=t.charCodeAt(s);return new Blob([a])}async saveGithubMounts(){const r=await this.manifestLock.acquire();try{const o=await(await(await this.root.getDirectoryHandle(".system",{create:!0})).getFileHandle("github_mounts.json",{create:!0})).createWritable(),e=Array.from(this.githubMounts.entries()).map(([t,a])=>({alias:t,owner:a.owner,repo:a.repo,branch:a.branch}));await o.write(JSON.stringify(e)),await o.close()}finally{r()}}async saveManifest(){const r=await this.manifestLock.acquire();try{const h=await this.root.getDirectoryHandle(".system",{create:!0}),i=async(o,e)=>{const a=await(await h.getFileHandle(o,{create:!0})).createWritable();await a.write(JSON.stringify(e)),await a.close()};i("attributes.json",this.attributes),i("tombstones.json",Array.from(this.tombstones))}finally{r()}}async getLineBoundaries(r,h,i,o,e){const t=await h.getFile(),{lastModified:a,size:s}=t;let l=this.lineIndexCache.get(r);(!l||l.mtime!==a||l.size!==s)&&(l=await this.rebuildLineIndex(h,i,a,s),this.lineIndexCache.set(r,l));const n=o<=1?0:l.offsets[o-1]??s;let c=s;return e!==void 0&&(c=l.offsets[e]??s),{startOffset:n,endOffset:c,totalSize:s}}async rebuildLineIndex(r,h,i,o){const e=[0],t=new Uint8Array(this.INDEX_CHUNK_SIZE);let a=null,s=null;h==="opfs"?a=await r.createSyncAccessHandle():s=await r.getFile();try{let l=0;for(;l<o;){let n=0;if(a)n=a.read(t,{at:l});else{const c=s.slice(l,l+this.INDEX_CHUNK_SIZE),f=new Uint8Array(await c.arrayBuffer());n=f.length,t.set(f)}for(let c=0;c<n;c++)t[c]===10&&e.push(l+c+1);l+=n}return{mtime:i,size:o,offsets:new Uint32Array(e)}}finally{a==null||a.close()}}parsePath(r){const i=(r.startsWith("/")?r.slice(1):r).split("/").filter(t=>t.length>0),o=i[0],e=this.mounts.has(o)||this.githubMounts.has(o);return{parts:i,alias:e?o:null,relativeParts:e?i.slice(1):i}}async resolveForRead(r){if(await this.init(),this.tombstones.has(r))throw new Error(`Entry not found (tombstoned): ${r}`);const{alias:h,relativeParts:i,parts:o}=this.parsePath(r);if(h){const e=await this.overlayRoot.getDirectoryHandle(h,{create:!0});try{return{handle:await this.traverse(e,i,!1),source:"opfs"}}catch{}if(this.mounts.has(h)){const t=this.mounts.get(h);return{handle:await this.traverse(t,i,!1),source:"local"}}if(this.githubMounts.has(h))try{return{handle:await this.traverse(e,i,!1),source:"opfs"}}catch{const a=await this.traverse(e,i,!0),s=this.githubMounts.get(h),l=await this.fetchGithubContent(s,i.join("/")),n=await a.createSyncAccessHandle();try{const c=new Uint8Array(await l.arrayBuffer());n.write(c,{at:0}),n.flush()}finally{n.close()}return{handle:a,source:"opfs"}}}return{handle:await this.traverse(this.root,o,!1),source:"opfs"}}async resolveForWrite(r){await this.init();const{alias:h,relativeParts:i,parts:o}=this.parsePath(r);if(this.tombstones.has(r)&&(this.tombstones.delete(r),await this.saveManifest()),!h){const s=await this.check_present(this.root,o);return{handle:await this.traverse(this.root,o,!0),created:!s}}const e=await this.overlayRoot.getDirectoryHandle(h,{create:!0});try{return{handle:await this.traverse(e,i,!1),created:!1}}catch{}const t=await this.traverse(e,i,!0);let a=!0;try{if(this.mounts.has(h)){const s=this.mounts.get(h),c=(await(await this.traverse(s,i,!1)).getFile()).stream().getReader(),f=await t.createSyncAccessHandle();try{let u=0;for(;;){const{done:g,value:w}=await c.read();if(g)break;f.write(w,{at:u}),u+=w.length}f.flush(),a=!1}finally{f.close()}}else if(this.githubMounts.has(h)){const s=this.githubMounts.get(h);try{const l=await this.fetchGithubContent(s,i.join("/")),n=await t.createSyncAccessHandle();try{const c=new Uint8Array(await l.arrayBuffer());n.write(c,{at:0}),n.flush(),a=!1}finally{n.close()}}catch{}}}catch{}return{handle:t,created:a}}async check_present(r,h){if(h.length===0)return!0;let i=r;const o=h[h.length-1];try{for(let e=0;e<h.length-1;e++)i=await i.getDirectoryHandle(h[e],{create:!1});return await i.getFileHandle(o).catch(async()=>{await i.getDirectoryHandle(o)}),!0}catch{}return!1}async traverse(r,h,i){if(h.length===0)return r;let o=r;for(let t=0;t<h.length-1;t++)o=await o.getDirectoryHandle(h[t],{create:i});const e=h[h.length-1];if(i)return await o.getFileHandle(e,{create:i});try{return await o.getFileHandle(e)}catch{try{return await o.getDirectoryHandle(e)}catch{throw new Error(`Path not found: ${h.join("/")}`)}}}filterTombstones(r){return r.filter(h=>!this.tombstones.has(h.path))}async meta(r,h,i){let o=0,e=0;if(r.kind==="file"){const t=await r.getFile();o=t.size,e=t.lastModified}return{name:r.name,kind:r.kind,path:h,size:o,lastModified:e,status:i}}async removeOverlayFile(r,h){try{const i=await this.overlayRoot.getDirectoryHandle(r),o=[];let e=i;const t=h[h.length-1],a=h.slice(0,-1);for(const s of a)o.push({name:s,handle:e}),e=await e.getDirectoryHandle(s);if(await e.removeEntry(t,{recursive:!0}),await this.isDirectoryEmpty(e)){let s=a[a.length-1];for(let l=o.length-1;l>=0;l--){const n=o[l];if(await n.handle.removeEntry(s,{recursive:!0}),l>0&&await this.isDirectoryEmpty(n.handle)){s=n.name;continue}else break}}}catch{}}async isDirectoryEmpty(r){for await(const h of r.keys())return!1;return!0}async getFilesRecursively(r,h=""){const i=[];for await(const[o,e]of r.entries()){const t=h?`${h}/${o}`:o;e.kind==="file"?i.push(t):i.push(...await this.getFilesRecursively(e,t))}return i}generateUnifiedDiff(r,h,i,o){const e=r?r.split(/\r?\n/):[],t=h?h.split(/\r?\n/):[],a=i.startsWith("/")?i.slice(1):i;let s=[];if(o==="new file")return s.push("--- /dev/null"),s.push(`+++ ${a}`),s.push(`@@ -0,0 +1,${t.length} @@`),t.forEach(f=>s.push(`+${f}`)),s.join(`
`);if(o==="deleted")return s.push(`--- ${a}`),s.push("+++ /dev/null"),s.push(`@@ -1,${e.length} +0,0 @@`),e.forEach(f=>s.push(`-${f}`)),s.join(`
`);const l=R.diff_main(r||"",h||"");R.diff_cleanupSemantic(l);const n=R.patch_make(r||"",l),c=R.patch_toText(n);return c.trim()?`--- a/${a}
+++ b/${a}
${decodeURIComponent(c)}`:""}async readGitIgnore(r,h){try{const i=this.mounts.get(r);if(i){let o=i;if(h)for(const a of h.split("/"))o=await o.getDirectoryHandle(a);return await(await(await o.getFileHandle(".gitignore")).getFile()).text()}}catch{}return null}async getScopedMatcher(r,h){const i=`${r}:${h}`;if(this.ignoreCache.has(i))return this.ignoreCache.get(i);if(h===""||h==="."){const l=new L;l.add(".git/");const n=await this.readGitIgnore(r,"");return n&&l.add(n,""),this.ignoreCache.set(i,l),l}const e=h.split("/").slice(0,-1).join("/"),a=(await this.getScopedMatcher(r,e)).clone(),s=await this.readGitIgnore(r,h);return s&&a.add(s,h),this.ignoreCache.set(i,a),a}invalidateIgnoreCache(r){for(const h of this.ignoreCache.keys())h.startsWith(`${r}:`)&&this.ignoreCache.delete(h)}gitToDmpFormat(r){const h=r.split(/\r?\n/),i=[];for(let o=0;o<h.length;o++){const e=h[o];if(e.startsWith("@@")||e.startsWith("Index:")||e.startsWith("===")){i.push(e);continue}if(e.startsWith("+")||e.startsWith("-")||e.startsWith(" ")){const t=e[0],a=e.substring(1);let s=!0;o+1<h.length&&h[o+1].startsWith("\\ No newline")&&(s=!1),i.push(t+encodeURI(a)+(s?"%0A":""))}else{if(e.startsWith("\\ No newline"))continue;i.push(e)}}return i.join(`
`)}async streamCopy(r,h,i,o,e){const a=new Uint8Array(65536);let s=o,l=i,n=e??h.getSize();for(;s>0;){const c=r.read(a.subarray(0,Math.min(65536,s)),{at:l});if(c===0)break;h.write(a.subarray(0,c),{at:n}),l+=c,n+=c,s-=c}}async _delete(r){for(const e of Object.keys(this.attributes))(e===r||e.startsWith(r+"/"))&&delete this.attributes[e];const{alias:h,relativeParts:i,parts:o}=this.parsePath(r);if(h){this.tombstones.add(r),await this.saveManifest();try{let e=await this.overlayRoot.getDirectoryHandle(h);const t=i.pop();for(const a of i)e=await e.getDirectoryHandle(a);await e.removeEntry(t,{recursive:!0})}catch{}}else{const e=o.slice(0,-1),t=o[o.length-1];let a=this.root;for(const s of e)a=await a.getDirectoryHandle(s);await a.removeEntry(t,{recursive:!0})}if(this.attributes[r]&&delete this.attributes[r],r.endsWith("/.gitignore")){const{alias:e}=this.parsePath(r);e&&this.invalidateIgnoreCache(e)}await this.saveManifest(),$("delete",r)}async init(){if(this.initialized)return;const r=await this.manifestLock.acquire();try{if(this.initialized)return;this.root=await navigator.storage.getDirectory(),this.overlayRoot=await this.root.getDirectoryHandle(".overlay",{create:!0}),await this.root.getDirectoryHandle("images",{create:!0});const h=await this.root.getDirectoryHandle(".system",{create:!0});try{const o=await(await h.getFileHandle("attributes.json")).getFile();this.attributes=JSON.parse(await o.text())}catch{this.attributes={}}try{const o=await(await h.getFileHandle("tombstones.json")).getFile(),e=JSON.parse(await o.text());this.tombstones=new Set(e)}catch{this.tombstones=new Set}try{const o=await(await h.getFileHandle("github_mounts.json")).getFile();JSON.parse(await o.text()).forEach(t=>{this.githubMounts.set(t.alias,{owner:t.owner,repo:t.repo,branch:t.branch,tree:new Map,treeFetched:!1})})}catch{}try{const i=await K();for(const[o,e]of i)this.mounts.set(o,e)}catch(i){console.error("Failed to load local mounts",i)}this.initialized=!0}finally{r()}}async mount(r,h){if(r===".system"||r===".overlay"||r==="images")throw new Error(`Mount ${r} is reserved`);if(await this.init(),this.mounts.has(r)||this.githubMounts.has(r))throw new Error(`Mount ${r} already in use`);return await G(r,h),this.mounts.set(r,h),!0}async mountGithub(r,h,i,o){if(r===".system"||r===".overlay"||r==="images")throw new Error(`Mount ${r} is reserved`);if(await this.init(),this.mounts.has(r)||this.githubMounts.has(r))throw new Error(`Mount ${r} already in use`);return this.githubMounts.set(r,{owner:h,repo:i,branch:o,tree:new Map,treeFetched:!1}),await this.saveGithubMounts(),!0}async unmount(r){const h=`/${r}/`;for(const i of Object.keys(this.attributes))i.startsWith(h)&&delete this.attributes[i];return this.mounts.has(r)&&(this.mounts.delete(r),await J(r)),this.githubMounts.has(r)&&(this.githubMounts.delete(r),await this.saveGithubMounts()),this.delete(".overlay/"+r),this.tombstones=new Set(Array.from(this.tombstones).filter(i=>!i.startsWith(r))),this.invalidateIgnoreCache(r),await this.saveManifest(),!0}async getMountInfo(r){if(await this.init(),this.githubMounts.has(r)){const h=this.githubMounts.get(r);return{type:"github",owner:h.owner,repo:h.repo,branch:h.branch}}return this.mounts.has(r)?{type:"local"}:null}async getMounts(){return await this.init(),[...Array.from(this.mounts.keys()),...Array.from(this.githubMounts.keys())]}async flushFile(r){await this.init();const h=await this.pathLocks.acquire(r);try{const{alias:i,relativeParts:o}=this.parsePath(r);if(!i)throw new Error("Cannot flush: Path is not part of a mounted workspace.");const e=this.mounts.get(i);if(!e)throw new Error("Mount point not found.");if(this.tombstones.has(r)){try{const u=o.slice(0,-1),g=o[o.length-1];let w=e;for(const d of u)w=await w.getDirectoryHandle(d);await w.removeEntry(g,{recursive:!0}),this.tombstones.delete(r),await this.saveManifest()}catch(u){console.warn(`Failed to delete local file (maybe already gone?) ${r}`,u)}return}let t;try{const u=await this.overlayRoot.getDirectoryHandle(i);t=await this.traverse(u,o,!1)}catch{throw new Error("Nothing to flush: File has no pending changes in overlay.")}const s=await(await t.getFile()).arrayBuffer();let l=e;for(let u=0;u<o.length-1;u++)l=await l.getDirectoryHandle(o[u],{create:!0});const n=o[o.length-1],f=await(await l.getFileHandle(n,{create:!0})).createWritable();await f.write(s),await f.close(),await this.removeOverlayFile(i,o),$("write",r)}finally{h()}}async flushMount(r){if(await this.init(),!this.mounts.has(r))throw new Error("Unknown mount alias");try{const o=await this.overlayRoot.getDirectoryHandle(r),e=await this.getFilesRecursively(o);for(const t of e){const a=`/${r}/${t}`;await this.flushFile(a)}}catch{}const h=`/${r}/`,i=Array.from(this.tombstones).filter(o=>o.startsWith(h));for(const o of i)await this.flushFile(o)}async discardChange(r){await this.init();const{alias:h,relativeParts:i}=this.parsePath(r);h&&(this.tombstones.has(r)&&(this.tombstones.delete(r),await this.saveManifest()),await this.removeOverlayFile(h,i),await this.present(r)?$("write",r):$("delete",r))}async diff(r){await this.init();const{alias:h,relativeParts:i}=this.parsePath(r);if(!h)throw new Error("Diff is only supported for mounted files.");const o=this.tombstones.has(r);let e="",t="",a=!1,s=!1;try{const l=this.mounts.get(h);e=await(await(await this.traverse(l,i,!1)).getFile()).text(),a=!0}catch{}if(o)s=!1;else try{const l=await this.overlayRoot.getDirectoryHandle(h);t=await(await(await this.traverse(l,i,!1)).getFile()).text(),s=!0}catch{if(a)return""}return!a&&!s?"":!a&&s?this.generateUnifiedDiff(null,t,r,"new file"):a&&!s?o?this.generateUnifiedDiff(e,null,r,"deleted"):"":this.generateUnifiedDiff(e,t,r)}async addTags(r,h){await this.init();const i=await this.pathLocks.acquire(r);try{this.attributes[r]||(this.attributes[r]={tags:[]});const o=new Set(this.attributes[r].tags);h.forEach(e=>o.add(e)),this.attributes[r].tags=Array.from(o),await this.saveManifest(),$("tags_change",r)}finally{i()}}async removeTags(r,h){await this.init();const i=await this.pathLocks.acquire(r);try{this.attributes[r]&&(this.attributes[r].tags=this.attributes[r].tags.filter(o=>!h.includes(o)),await this.saveManifest(),$("tags_change",r))}finally{i()}}async searchByTags(r){await this.init();const h=[];for(const[i,o]of Object.entries(this.attributes))r.every(e=>o.tags.includes(e))&&h.push(i);return h}async getTags(r){var i;await this.init();const h=await this.pathLocks.acquire(r);try{return((i=this.attributes[r])==null?void 0:i.tags)||[]}finally{h()}}async list(r="/",h=!1){await this.init();let i=[];const{alias:o,relativeParts:e}=this.parsePath(r);if(r==="/"){for(const t of this.mounts.keys())i.push({name:t,kind:"directory",path:`/${t}`,size:0,status:"original"});for(const t of this.githubMounts.keys())i.push({name:t,kind:"directory",path:`/${t}`,size:0,status:"original"});for await(const[t,a]of this.root.entries())(!h||!t.startsWith("."))&&i.push(await this.meta(a,`/${t}`,"original"));return this.filterTombstones(i)}if(o){const t=new Map,a=e.join("/"),s=await this.getScopedMatcher(o,a),l=n=>{const c=a?`${a}/${n}`:n;return s.ignores(c)};try{if(this.mounts.has(o)){let n=this.mounts.get(o);for(const c of e)n=await n.getDirectoryHandle(c);for await(const[c,f]of n.entries())l(c)||t.set(c,await this.meta(f,`${r}/${c}`,"original"))}else if(this.githubMounts.has(o)){const n=this.githubMounts.get(o);await this.ensureGithubTree(o);const c=a?a+"/":"";for(const[f,u]of n.tree.entries())if(f.startsWith(c)){const g=f.slice(c.length);g&&!g.includes("/")&&(l(u.name)||t.set(u.name,{...u,path:`${r}/${u.name}`}))}}}catch(n){return console.error(`Failed to list files in ${r}`,n),[]}try{let n=await this.overlayRoot.getDirectoryHandle(o);for(const c of e)n=await n.getDirectoryHandle(c);for await(const[c,f]of n.entries())if(!l(c)){const u=t.has(c)?"modified":"new";t.set(c,await this.meta(f,`${r}/${c}`,u))}}catch{}i=Array.from(t.values())}else try{const t=await this.traverse(this.root,this.parsePath(r).parts,!1);for await(const[a,s]of t.entries())i.push(await this.meta(s,`${r}/${a}`,"original"))}catch{return[]}return this.filterTombstones(i)}async getMetadata(r){if(await this.init(),this.tombstones.has(r))throw new Error("ENOENT");try{const{handle:h,source:i}=await this.resolveForRead(r),{alias:o}=this.parsePath(r),e=i==="local"?"original":o?"modified":"original";return await this.meta(h,r,e)}catch{throw new Error("ENOENT")}}async listRecursive(r="/",h=!1){const i=await this.listLimiter.run(()=>this.list(r,h));return(await Promise.all(i.map(async e=>e.kind==="directory"?[e,...await this.listRecursive(e.path)]:[e]))).flat()}async listRecursiveTree(r="/",h=!1){const i={kind:"directory",path:r,children:{}},o=await this.listLimiter.run(()=>this.list(r,h));return await Promise.all(o.map(async e=>{e.kind==="file"?i.children[e.name]=e:i.children[e.name]=await this.listRecursiveTree(e.path,h)})),i}async write(r,h,i=!0){if(i&&r.startsWith("/."))throw new Error("The write access to the system files is not allowed");const o=await this.pathLocks.acquire(r);try{const{handle:e,created:t}=await this.resolveForWrite(r),a=await e.createSyncAccessHandle();try{const s=typeof h=="string"?this.textEncoder.encode(h):h;if(a.truncate(0),a.write(s,{at:0}),a.flush(),r.endsWith(".gitignore")){const{alias:l}=this.parsePath(r);l&&this.invalidateIgnoreCache(l)}$(t?"new_filepath":"write",r)}finally{a.close(),this.lineIndexCache.delete(r)}}finally{o()}}async applyPatch(r,h,i=!0){if(i&&r.startsWith("/."))throw new Error("The write access to the system files is not allowed");const o=h.indexOf("@@");if(o===-1)throw Error("No valid patches found. Patches must start with '@@'.");const e=h.substring(o),t=this.gitToDmpFormat(e),a=R.patch_fromText(t);if(a.length===0)throw Error("No valid patches parsed. Ensure headers '@@ -old,count +new,count @@' are correct.");const s=await this.pathLocks.acquire(r);try{const{handle:l,created:n}=await this.resolveForWrite(r),c=await l.createSyncAccessHandle();try{const f=c.getSize();let u=new Uint8Array(f);c.read(u,{at:0});let g=new TextDecoder().decode(u);u=null,g=g.replace(/\r\n/g,`
`);let[w,d]=R.patch_apply(a,g);if(g=null,d.every(v=>v===!0)){let v=this.textEncoder.encode(w);w=null,c.write(v,{at:0}),c.truncate(v.length),v=null,c.flush(),this.lineIndexCache.delete(r),$(n?"new_filepath":"write",r)}else{const v=d.map((y,m)=>y?null:m+1).filter(y=>y!==null);throw n&&await this._delete(r),new Error(`Patch failed: ${v.length} of ${d.length} hunks failed to apply. Failed hunks: #${v.join(", #")}.`)}}finally{c.close()}}finally{s()}}async append(r,h,i=!0){if(i&&r.startsWith("/."))throw new Error("The write access to the system files is not allowed");const o=await this.pathLocks.acquire(r);try{const{handle:e,created:t}=await this.resolveForWrite(r),a=await e.createSyncAccessHandle();try{const s=typeof h=="string"?this.textEncoder.encode(h+`
`):h,l=a.getSize();a.write(s,{at:l}),a.flush(),$(t?"new_filepath":"write",r)}finally{a.close(),this.lineIndexCache.delete(r)}}finally{o()}}async replaceRange(r,h,i,o,e,t,a=!0){if(a&&r.startsWith("/."))throw new Error("The write access to the system files is not allowed");await this.init();const s=(await this.readWindow(r,h,h)).trim(),l=(await this.readWindow(r,i,i)).trim();if(e&&s!==e.trim())throw new Error(`Safety Mismatch at start line ${h}.
Expected: "${e.trim()}"
Actual:   "${s.trim()}"`);if(t&&l!==t.trim())throw new Error(`Safety Mismatch at end line ${i}.
Expected: "${t.trim()}"
Actual:   "${l.trim()}"`);const n=await this.pathLocks.acquire(r);try{const{handle:c,created:f}=await this.resolveForWrite(r),{startOffset:u,endOffset:g,totalSize:w}=await this.getLineBoundaries(r,c,"opfs",h,i),d=crypto.randomUUID(),v=await this.root.getDirectoryHandle(".system",{create:!0}),y=await v.getFileHandle(`swap_${d}.tmp`,{create:!0}),m=await c.createSyncAccessHandle(),b=await y.createSyncAccessHandle();try{u>0&&await this.streamCopy(m,b,0,u,0);const E=k=>{let F;typeof k=="string"?F=this.textEncoder.encode(k):F=k,b.write(F,{at:b.getSize()})};if(typeof o=="string")E(o);else for(let k of o)E(k);const _=w-g;_>0&&await this.streamCopy(m,b,g,_,b.getSize()),m.truncate(b.getSize()),await this.streamCopy(b,m,0,b.getSize(),0),$(f?"new_filepath":"write",r)}finally{m.close(),b.close(),await v.removeEntry(`swap_${d}.tmp`)}}finally{n()}}async readWindow(r,h,i){const o=await this.pathLocks.acquire(r);try{const{handle:e,source:t}=await this.resolveForRead(r),{startOffset:a,endOffset:s}=await this.getLineBoundaries(r,e,t,h,i);return a>=s?"":await(await e.getFile()).slice(a,s).text()}finally{o()}}async grep(r,h={}){await this.init();const i=await this.listRecursive("/");let o=h.regexPath?new RegExp(h.regexPath):void 0;const e=i.filter(a=>{var s,l,n,c;return!(a.kind!=="file"||(s=h.rootPath)!=null&&s.length&&!a.path.startsWith(h.rootPath)||(l=h.paths)!=null&&l.length&&!h.paths.includes(a.path)||(n=h.includePaths)!=null&&n.length&&!h.includePaths.some(f=>a.path.includes(f))||(c=h.excludePaths)!=null&&c.length&&h.excludePaths.some(f=>a.path.includes(f))||o&&!o.test(a.path))});return(await Promise.all(e.map(async a=>this.grepLimiter.run(async()=>({path:a.path,hits:await this.grepFile(a.path,r)}))))).filter(a=>a.hits.length).flat()}async grepFile(r,h){const i=await this.pathLocks.acquire(r);try{const{handle:o}=await this.resolveForRead(r);if(o.kind!=="file")return[];const t=(await o.getFile()).stream().getReader(),a=[];let s=1,l="";for(;;){const{done:n,value:c}=await t.read();if(n)break;const f=this.textDecoder.decode(c,{stream:!0}),u=(l+f).split(/\r?\n/);l=u.pop()||"";for(const g of u)g.includes(h)&&a.push({line:s,content:g.trim()}),s++}return l.includes(h)&&(s++,a.push({line:s,content:l.trim()})),a}finally{i()}}async delete(r,h=!0){if(h&&r.startsWith("/."))throw new Error("The write access to the system files is not allowed");await this.init();const i=await this.pathLocks.acquire(r);try{await this._delete(r)}finally{i()}}async countLines(r){const h=await this.pathLocks.acquire(r);try{const{handle:i,source:o}=await this.resolveForRead(r);let e=0;if(o==="opfs"){const t=await i.createSyncAccessHandle();try{const a=t.getSize();if(a===0)return 0;const s=new Uint8Array(64*1024);let l=0;for(;l<a;){const n=t.read(s,{at:l});for(let c=0;c<n;c++)s[c]===10&&e++;l+=n}}finally{t.close()}}else{const t=await i.getFile();if(t.size===0)return 0;const a=t.stream().getReader();for(;;){const{done:s,value:l}=await a.read();if(s)break;for(let n=0;n<l.length;n++)l[n]===10&&e++}}return e+1}finally{h()}}async readFile(r){const{handle:h}=await this.resolveForRead(r);return h.getFile()}async readBytes(r,h,i){const{handle:o,source:e}=await this.resolveForRead(r);if(e==="opfs"){const t=await o.createSyncAccessHandle();try{const a=new Uint8Array(i),s=t.read(a,{at:h});return a.subarray(0,s)}finally{t.close()}}else{const s=await(await o.getFile()).slice(h,h+i).arrayBuffer();return new Uint8Array(s)}}async writeBytes(r,h,i){const o=await this.pathLocks.acquire(r);try{const{handle:e,created:t}=await this.resolveForWrite(r),a=await e.createSyncAccessHandle();try{const s=a.write(h,{at:i});return a.flush(),$(t?"new_filepath":"write",r),s}finally{a.close()}}finally{o()}}async truncate(r,h){const i=await this.pathLocks.acquire(r);try{const{handle:o,created:e}=await this.resolveForWrite(r),t=await o.createSyncAccessHandle();try{t.truncate(h),t.flush(),$(e?"new_filepath":"write",r)}finally{t.close(),this.lineIndexCache.delete(r)}}finally{i()}}async rename(r,h){const i=[r,h].sort(),o=await this.pathLocks.acquire(i[0]),e=await this.pathLocks.acquire(i[1]);try{const{handle:t,created:a}=await this.resolveForWrite(r);if(a)throw await this._delete(r),Error("The old file is not present in: "+r);const{handle:s,created:l}=await this.resolveForWrite(r),n=await t.createSyncAccessHandle(),c=await s.createSyncAccessHandle();try{const f=n.getSize();c.truncate(0),await this.streamCopy(n,c,0,f,0),c.flush()}finally{n.close(),c.close()}this.attributes[r]&&(this.attributes[h]={...this.attributes[r]}),await this._delete(r)}finally{e(),o()}}async mkdir(r){await this.init();const{alias:h,relativeParts:i,parts:o}=this.parsePath(r),e=await this.pathLocks.acquire(r);try{if(this.tombstones.has(r)&&(this.tombstones.delete(r),await this.saveManifest()),h){let a=await this.overlayRoot.getDirectoryHandle(h,{create:!0});for(const s of i)a=await a.getDirectoryHandle(s,{create:!0})}else{let t=this.root;for(const a of o)t=await t.getDirectoryHandle(a,{create:!0})}$("new_filepath",r)}finally{e()}}async present(r){return await this.init(),this.check_present(this.root,this.parsePath(r).parts)}async storeImage(r,h){await this.init();const i=`/images/${crypto.randomUUID()+X(r)}`;return await this.write(i,h),i}}const p=new Z;self.onmessage=async M=>{const{id:r,method:h,args:i}=M.data;try{let o;switch(h){case"mount":o=await p.mount(i.alias,i.handle);break;case"mountGithub":o=await p.mountGithub(i.alias,i.owner,i.repo,i.branch);break;case"setGithubToken":o=await p.setGithubToken(i.token);break;case"getMounts":o=await p.getMounts();break;case"getMountInfo":o=await p.getMountInfo(i.alias);break;case"unmount":o=await p.unmount(i.alias);break;case"flushFile":o=await p.flushFile(D(i.path));break;case"flushMount":o=await p.flushMount(i.alias);break;case"discardChange":o=await p.discardChange(D(i.path));break;case"diff":o=await p.diff(D(i.path));break;case"addTags":o=await p.addTags(D(i.path),i.tags);break;case"removeTags":o=await p.removeTags(D(i.path),i.tags);break;case"searchByTags":o=await p.searchByTags(i.tags);break;case"getTags":o=await p.getTags(D(i.path));break;case"getMetadata":o=await p.getMetadata(D(i.path));break;case"list":o=await p.list(D(i.path),i.ignoreSystem);break;case"listRecursive":o=await p.listRecursive(D(i.path),i.ignoreSystem);break;case"listRecursiveTree":o=await p.listRecursiveTree(D(i.path),i.ignoreSystem);break;case"write":o=await p.write(D(i.path),i.content,i.protectSystem);break;case"applyPatch":o=await p.applyPatch(D(i.path),i.content,i.protectSystem);break;case"replaceRange":o=await p.replaceRange(D(i.path),i.startLine,i.endLine,i.newContent,i.expectedStart,i.expectedEnd,i.protectSystem);break;case"append":o=await p.append(D(i.path),i.content,i.protectSystem);break;case"readWindow":o=await p.readWindow(D(i.path),i.startLine,i.endLine);break;case"grep":i.options.rootPath&&(i.options.rootPath=D(i.options.rootPath)),i.options.includePaths&&(i.options.includePaths=i.options.includePaths.map(e=>D(e))),i.options.excludePaths&&(i.options.excludePaths=i.options.excludePaths.map(e=>D(e))),o=await p.grep(i.query,i.options);break;case"grepFile":o=await p.grepFile(D(i.path),i.query);break;case"delete":o=await p.delete(D(i.path));break;case"countLines":o=await p.countLines(D(i.path));break;case"readFile":o=await p.readFile(D(i.path));break;case"readBytes":o=await p.readBytes(D(i.path),i.offset,i.length);break;case"writeBytes":o=await p.writeBytes(D(i.path),i.buffer,i.offset);break;case"truncate":o=await p.truncate(D(i.path),i.size);break;case"rename":o=await p.rename(D(i.oldPath),D(i.newPath));break;case"mkdir":o=await p.mkdir(D(i.path));break;case"storeImage":o=await p.storeImage(i.mimeType,i.data);break;case"present":o=await p.present(D(i.path));break;default:throw new Error(`Unknown method: ${h}`)}self.postMessage({id:r,status:"success",result:o})}catch(o){self.postMessage({id:r,status:"error",error:o.message})}}})();
